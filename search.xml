<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>re基础</title>
      <link href="/2025/04/19/re%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/04/19/re%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="REVERSE"><a href="#REVERSE" class="headerlink" title="REVERSE"></a>REVERSE</h1><h2 id="1-文件的编译"><a href="#1-文件的编译" class="headerlink" title="1.文件的编译"></a>1.文件的编译</h2><p>计算机是无法直接执行.c文件的，需要进行对文件的编译，将文件中的代码转换成二进制并进行链接才能变成常见的可执行程序.exe文件</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/01bfdc12-0331-47bb-ab13-cfd62b2841ba.png?raw=true"></p><p>其中，在第一步预处理成.i文件时，会将.c文件进行宏替换(<em>将#include和#define指向的文件插入该行内</em>)</p><p>第二步中，.i文件被编译成汇编语言程序（根据电脑cpu指令集架构有所差异）</p><h2 id="2-指令集"><a href="#2-指令集" class="headerlink" title="2.指令集"></a>2.指令集</h2><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20250419102804524.png" alt="image-20250419102804524"></p><p>根据地址，我们可以从寄存器中查询到存放的值</p>]]></content>
      
      
      <categories>
          
          <category> learnbyself </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>个人AI模型分享</title>
      <link href="/2025/02/19/%E4%B8%AA%E4%BA%BAAI%E6%A8%A1%E5%9E%8B%E5%88%86%E4%BA%AB/"/>
      <url>/2025/02/19/%E4%B8%AA%E4%BA%BAAI%E6%A8%A1%E5%9E%8B%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="AI模型分享页"><a href="#AI模型分享页" class="headerlink" title="AI模型分享页"></a>AI模型分享页</h1><h2 id="一-RVC模型"><a href="#一-RVC模型" class="headerlink" title="一.RVC模型"></a>一.RVC模型</h2><p>1.北部玄驹(KitasanBlack)</p><p>训练素材总数:210</p><p>下载地址：<br><a href="https://pan.baidu.com/s/15s9SzcSxlOfToIcHXNmUtA?pwd=kita">https://pan.baidu.com/s/15s9SzcSxlOfToIcHXNmUtA?pwd=kita</a></p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/meit/kitasan1.png?raw=true"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++学习</title>
      <link href="/2024/11/07/C-%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/11/07/C-%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>在完成了对C语言的学习后，我打算再更深一步学习C语言的升级版本，C++，本篇文章我将作为学习C++的一篇总结笔记，相较C语言的学习，我将不会把一些系统底层的知识写在里面，仅仅是针对C++的一篇笔记</p><h2 id="一-对C-的初步探索"><a href="#一-对C-的初步探索" class="headerlink" title="一.对C++的初步探索"></a>一.对C++的初步探索</h2><p>hello world在C++中的写法：</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/C++Learn/Cp.png?raw=true"></p><p>C++相比C语言，C++程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互（面向对象的编程语言）</p><br/><p>甚至在C++中，可以在一行放多个代码，如：</p><p>![屏幕截图 2024-11-07 215743](<a href="https://raw.githubusercontent.com/SUDG01/tuchuang/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">https://raw.githubusercontent.com/SUDG01/tuchuang/main/屏幕截图</a> 2024-11-07 215743.png)</p><p>using namespace std是告诉编译器使用std命名空间</p><h3 id="三字符组"><a href="#三字符组" class="headerlink" title="三字符组"></a>三字符组</h3><p>总是以两个问号开头，可以用于替换某些字符，以下为常用的字符序列</p><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241107220233243.png" alt="image-20241107220233243"></p><br/><p>对所大部分编程语言通用，但还是提一嘴，除了用于分隔代码的空格，多的C++（包括其他语言）编译器都忽略不计</p>]]></content>
      
      
      <categories>
          
          <category> 周报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程的使用</title>
      <link href="/2024/11/07/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/11/07/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="一-线程-Thread"><a href="#一-线程-Thread" class="headerlink" title="一.线程(Thread)"></a>一.线程(Thread)</h2><p>定义：一个线程就是一个”执行流”，每个线程之间都可以按照顺序执行字节的代码，可以”同时”执行着多份代码，其中，main()一般被称为主线程(Main Thread)</p><p>多进程同样可以实现同时执行任务，但是</p><p><strong>线程比进程更加轻量</strong></p><p>而且，人们为了更进一步，又诞生出了，”线程池”和”协程”</p><br/><h3 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a>进程和线程的区别？</h3><ul><li>进程是包含线程的，每个进程至少有一个线程存在，即主线程</li><li>进程和进程之间不共享内存空间，同一个进程之间共享同一个内存空间</li><li>进程是系统分配资源的最小单位，线程是系统调度的最小单位</li><li>一个进程挂了一般不会影响到其他进程，但是可能会把进程内的线程一起带走</li></ul><h2 id="二-C语言中的线程操作"><a href="#二-C语言中的线程操作" class="headerlink" title="二.C语言中的线程操作"></a>二.C语言中的线程操作</h2><p><strong>创建线程</strong>，利用posix库，可以创建线程</p><pre><code class="highlight c"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span>pthread_create(thread,attr,start_routine,arg);</code></pre><p>参数解释：</p><ul><li>thread 指向线程表示符指针</li><li>attr 一个不透明的属性对象，可以被用来设置线程属性。可以指定对象，默认值为NULL</li><li>start_routine 线程运行函数的起始地址，一旦线程被创建就会执行</li><li>运行函数的参数。他必须通过把引用作为指针强制转换为void类型进行传递。如果没有，则用NULL</li></ul><p>线程创建成功后，函数返回0，若返回值不为0则说明创建线程失败</p><br/><p><strong>终止线程</strong></p><pre><code class="highlight c"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span>pthread_exit(status);</code></pre><p>but <strong>pthread_thread</strong>是用于显式地退出一个线程，一般这个线程是在函数是在线程完成工作后无需存在时调用</p><br/><p><strong>连接和分离线程</strong></p><pre><code class="highlight c">pthread_join(threadid,status);pthread_detach(threadid);</code></pre><p>pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连。pthread_join() 函数来等待线程的完成</p><br/><br/><h2 id="尝试使用"><a href="#尝试使用" class="headerlink" title="尝试使用"></a>尝试使用</h2><h3 id="1-无参数传递的并发编程"><a href="#1-无参数传递的并发编程" class="headerlink" title="1.无参数传递的并发编程"></a>1.无参数传递的并发编程</h3><p>其中使用的时候遇到了很多问题，翻找文章可以发现解决方案</p><p><a href="https://blog.csdn.net/Dreaming_love_/article/details/140276187">关于VS2022安装pthread.h多线程库的问题_pthread.h库怎么安装?-CSDN博客</a></p><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241112210639986.png" alt="image-20241112210639986"></p><p>运行结果如下</p><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241112210733773.png" alt="image-20241112210733773"></p><p>5个线程同时运行HelloWD函数</p><br/><h3 id="2-传递参数的并发编程"><a href="#2-传递参数的并发编程" class="headerlink" title="2.传递参数的并发编程"></a>2.传递参数的并发编程</h3><p>根据上部分学习的知识，写了以下程序</p><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241112213316581.png" alt="image-20241112213316581"></p><p>发现运行出来结果并不是我想要的</p><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241112213358559.png" alt="image-20241112213358559"></p><p>虽然没有输出上面那段函数的内容，但是并没有报线程创建失败</p><p>研究了线程创建函数的传参，得知传递的参数必需为无类型指针，将</p><pre><code class="highlight c">rc = pthread_create(&amp;exec1,<span class="literal">NULL</span>,HelloWD,<span class="literal">NULL</span>); <span class="comment">//最后的NULL修改为传递的参数</span><span class="comment">//</span>rc = pthread_create(&amp;exec1,<span class="literal">NULL</span>,HelloWD,(<span class="type">void</span>*)&amp;numthread[i]); <span class="comment">//强制转化</span></code></pre><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241112214023780.png"></p><p>可以看到，线程正确创建并依次执行了</p><br/><h3 id="3-结构体参数传递"><a href="#3-结构体参数传递" class="headerlink" title="3.结构体参数传递"></a>3.结构体参数传递</h3><p>相比上一个，多出结构体参与参数的传递</p><p>结构体定义中，threadid用于记录线程的序号，msg用于记录线程的名称，用数组index[5]来记录threadid和msg的值</p><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241113212105974.png" alt="image-20241113212105974"></p><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241113212129211.png" alt="image-20241113212129211"></p><p>最后成功运行结果为</p><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241113212204062.png" alt="image-20241113212204062"></p><br/><h3 id="4-线程之间的连接"><a href="#4-线程之间的连接" class="headerlink" title="4.线程之间的连接"></a>4.线程之间的连接</h3><p>按照示例，模仿着敲了一下</p><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241114212652934.png" alt="image-20241114212652934"></p><p>运行结果是这样的</p><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241114212724916.png" alt="image-20241114212724916"></p><p>本实例实现了调用线程后，使用pthread_join函数等待threadid线程运行结束后再运行</p><p>其中：</p><p>1.pthread_attr_init是用于初始化线程对象（本例是attr）</p><br/><p>2.pthread_attr_setdetachstate 用于设置线程的分离状态并设置为PTHREAD_CREATE_JOINABLE即可以被其他线程通过pthread_join来等待结束的</p><br/><p>3.pthread_attr_destroy是用于销毁属性对象，释放资源</p><p><br/><br/></p><h3 id="5-多线程作用的实现"><a href="#5-多线程作用的实现" class="headerlink" title="5.多线程作用的实现"></a>5.多线程作用的实现</h3><pre><code class="highlight c"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;pthreadVC2.lib&quot;</span>)          <span class="comment">//用于解决无法解析的外部符号 _imp_pthread_create问题</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">float</span> a;<span class="type">float</span> b;&#125;Arg;<span class="type">float</span> *<span class="title function_">func1</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;<span class="type">int</span> i;<span class="type">float</span>* result;result = (<span class="type">float</span>*)<span class="built_in">malloc</span>((<span class="keyword">sizeof</span>(<span class="type">float</span>)) * <span class="number">2</span>);     <span class="comment">//分配内存</span><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;result[<span class="number">0</span>] = a + b;result[<span class="number">1</span>] = a - b;&#125;<span class="keyword">return</span> result;&#125;<span class="type">float</span>* <span class="title function_">func2</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;<span class="type">int</span> i;<span class="type">float</span>* result;result = (<span class="type">float</span>*)<span class="built_in">malloc</span>((<span class="keyword">sizeof</span>(<span class="type">float</span>)) * <span class="number">2</span>);<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;result[<span class="number">0</span>] = a * b;result[<span class="number">1</span>] = a / b;&#125;<span class="keyword">return</span> result;&#125;<span class="type">void</span> *<span class="title function_">thread_func1</span><span class="params">(<span class="type">void</span>* args)</span> &#123;Arg* data = (Arg*)args;<span class="keyword">return</span> func1(data-&gt;a, data-&gt;b);&#125;<span class="type">void</span>* <span class="title function_">thread_func2</span><span class="params">(<span class="type">void</span>* args)</span> &#123;Arg* data = (Arg*)args;<span class="keyword">return</span> func2(data-&gt;a, data-&gt;b);&#125;<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;<span class="type">pthread_t</span> thread1;<span class="type">pthread_t</span> thread2;<span class="type">clock_t</span> start;<span class="type">clock_t</span> end;<span class="type">float</span> a = <span class="number">3.1</span>;<span class="type">float</span> b = <span class="number">2.4</span>;Arg ab;ab.a = a;ab.b = b;<span class="type">void</span>* r1, * r2;start = clock();pthread_create(&amp;thread1, <span class="literal">NULL</span>, thread_func1, (<span class="type">void</span>*)&amp;ab);pthread_create(&amp;thread2, <span class="literal">NULL</span>, thread_func2, (<span class="type">void</span>*)&amp;ab);   pthread_join(thread1, &amp;r1);pthread_join(thread2, &amp;r2);end = clock();<span class="type">float</span> lasttime = (<span class="type">float</span>(end - start)) / CLOCKS_PER_SEC;<span class="built_in">printf</span>(<span class="string">&quot;timeused:%f\n&quot;</span>, lasttime);<span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><p>写了这样一个程序，使用time.h库中的clock来计算程序运行花费的时间</p><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241120154837717.png" alt="image-20241120154837717"></p><p>按照上面的写法，计算总共花费0.714s</p><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241120155703694.png" alt="image-20241120155703694"></p><p>但是，如果我取消多线程用法，改用单线程直接计算</p><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241120155752094.png" alt="image-20241120155752094"></p><p>执行两个运算函数花费的时间相当于原来时间的两倍</p><h3 id="6-互斥锁和条件"><a href="#6-互斥锁和条件" class="headerlink" title="6.互斥锁和条件"></a>6.互斥锁和条件</h3><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241127211322210.png" alt="image-20241127211322210"></p><p>我们可以利用互斥锁，来避免两个线程同时调用同一块内存导致的结果错误</p><p>设置一个情景，猫一次要吃二十条鱼，但是框内只能装10条鱼，如果不加以限制，那么猫和渔夫就同时使用框里的鱼，那么渔夫就会一直捕捉鱼。现在限制只能在框装满鱼后猫才能去吃</p><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241127220658787.png" alt="image-20241127220658787"><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241127220747723.png" alt="image-20241127220747723"></p><p>其中，pthread_cond_wait(等待的信号，释放的锁)函数，是用于等待某个信号的发出，如果等到了某个信号，那么将释放互斥锁，发出信号可以使用pthread_cond_signal(发出的信号)</p><p>利用两者之间的关系，可以实现多线程之间相互兼容</p><p>此代码运行后结果：</p><p><img src="https://raw.githubusercontent.com/SUDG01/tuchuang/main/image-20241127221203418.png" alt="image-20241127221203418"></p><br/><h2 id="多线程总结"><a href="#多线程总结" class="headerlink" title="多线程总结"></a>多线程总结</h2><h3 id="线程创建与管理"><a href="#线程创建与管理" class="headerlink" title="线程创建与管理"></a>线程创建与管理</h3><p>pthread_create：创建一个新的线程并执行指定的起始函数<br>pthread_join：等待指定线程结束并获取其返回值<br>pthread_detach：分离线程，使其在终止时自动回收资源，无需pthread_join<br>pthread_exit：线程主动退出，可指定返回值</p><br/><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>pthread_mutex_init，pthread_mutex_destroy：初始化和销毁互斥锁<br>pthread_mutex_lock，pthread_mutex_unlock：锁定和解锁互斥锁<br>pthread_cond_init，pthread_cond_destroy：初始化和销毁条件变量<br>pthread_cond_wait，pthread_cond_signal，pthread_cond_broadcast：线程在条件变量上等待、发送信号或广播信号</p><br/><h3 id="线程属性与调度"><a href="#线程属性与调度" class="headerlink" title="线程属性与调度"></a>线程属性与调度</h3><p>pthread_attr_init，pthread_attr_destroy：初始化和销毁线程属性对象<br>pthread_attr_setdetachstate，pthread_attr_getdetachstate：设置和获取线程的分离状态（joinable或detached）<br>pthread_attr_setschedparam，pthread_attr_getschedparam：设置和获取线程的调度参数（优先级等）<br>pthread_setschedprio：直接设置线程的优先级</p><br/><h3 id="线程取消与清理"><a href="#线程取消与清理" class="headerlink" title="线程取消与清理"></a>线程取消与清理</h3><p>pthread_cancel：向指定线程发送取消请求<br>pthread_setcancelstate，pthread_getcancelstate：设置和获取线程的取消状态（enable或disable）<br>pthread_setcanceltype，pthread_getcanceltype：设置和获取线程的取消类型（asynchronous或deferred）<br>pthread_cleanup_push，pthread_cleanup_pop：注册和撤销清理函数，用于线程取消或正常退出时释放资源</p><br/><h3 id="线程特定数据"><a href="#线程特定数据" class="headerlink" title="线程特定数据"></a>线程特定数据</h3><p>pthread_key_create，pthread_key_delete：创建和删除线程特定数据键<br>pthread_setspecific，pthread_getspecific：为当前线程设置和获取与特定键关联的数据</p><br/><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>pthread_self：获取当前线程的ID<br>pthread_equal：比较两个线程ID是否相等</p>]]></content>
      
      
      <categories>
          
          <category> 周报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编学习</title>
      <link href="/2024/10/26/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/10/26/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言学习"><a href="#汇编语言学习" class="headerlink" title="汇编语言学习"></a>汇编语言学习</h1><p>以8086CPU为例来进行学习</p><h2 id="汇编语言的基础知识"><a href="#汇编语言的基础知识" class="headerlink" title="汇编语言的基础知识"></a>汇编语言的基础知识</h2><p>汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令是机器指令便于记忆的书写格式。</p><p>每一种CPU都有自己的汇编指令集</p><p>汇编指令有一下三类指令组成</p><p>(1)汇编指令：机器码的助记符，有对应的机器码</p><p>(2)伪指令：没有对应的机器码，由编译器执行，计算机并不执行</p><p>(3)其他符号：如+，-，*，&#x2F;等，由编译器识别，没有对应机器码</p><br/><p>CPU在内存中读数据，需要和存储器进行3类信息的交互（CPU可以直接使用的信息在存储器中存放）</p><ul><li>存储单元的地址（地址信息）</li><li>器件的选择，读或写的命令（控制信息）</li><li>读或写的数据（数据信息）</li></ul><p>tip：在存储器中指令和数据没有任何区别，都是二进制信息</p><p>每一个CPU都有许多管脚，这些管脚和总线相连，所以说CPU可以引出3中总线的宽度标志了这个CPU的不同方面的性能：</p><ul><li>地址总线的宽度决定了CPU的寻址能力</li><li>数据总线的宽度决定了CPU与其他器件进行数据传送时的依次数据传送量</li><li>控制总线的宽度决定了CPU对系统中其他器件的控制能力</li></ul><h3 id="存储器："><a href="#存储器：" class="headerlink" title="存储器："></a>存储器：</h3><p>从读写属性上看分为两类：RAM(随机存储器)，ROM(只读存储器)</p><p>其中，在功能和连接上又分为：</p><ul><li>随机存储器</li><li>装有BIOS的ROM</li><li>接口卡的RAM</li></ul><h3 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h3><p>存储器，在物理上是独立的器件，但在以下两点上相同</p><ul><li>都和CPU的总线相连</li><li>CPU对他们进行读或写的时候都通过控制线发出内存读写命令</li></ul><p>也就是说，CPU在操纵他们的时候，把他们都当做内存来对待，把他们总的看做一个由若干储存单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/HB.png?raw=true"></p><p>每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="1-通用寄存器"><a href="#1-通用寄存器" class="headerlink" title="1.通用寄存器"></a>1.通用寄存器</h3><p>8086CPU的所有寄存器都是16位的，可以存放两个字节</p><p>AX,BX,CX,DX这四个寄存器都是8位的，并且通用，为了保证兼容，使原来基于上代CPU编写的程序稍加修改就可以运行在8086CPU上，这4个寄存器都可以分为两个可独立使用的8位寄存器来用：</p><ul><li>AX可分为AH和AL</li><li>BX可分为BH和BL</li><li>CH可分为CH和CL</li><li>DX可分为DH和DL</li></ul><p><img src="https://github.com/SUDG01/tuchuang/blob/main/HD/HB1.png?raw=true"></p><p>数据：18</p><p>二进制表示：10010</p><h3 id="2-字在寄存器中的储蓄"><a href="#2-字在寄存器中的储蓄" class="headerlink" title="2.字在寄存器中的储蓄"></a>2.字在寄存器中的储蓄</h3><ul><li>字节：记为Byte，一个字节由8个bit组成，可以存在8位寄存器中</li><li>字：结尾word，一个字由两个字节组成，这两个字节分别被称为这个字的高位字节和低位字节（前8位为高位字节，后8位为低位字节）</li></ul><h3 id="3-几条汇编指令"><a href="#3-几条汇编指令" class="headerlink" title="3.几条汇编指令"></a>3.几条汇编指令</h3><pre><code class="highlight assembly">mov ax,18                        #将18写入寄存器AX中mov ah,78   #将78写入寄存器AH中add ax,8   #将寄存器AX中的数值加上8mov ax,bx   #将寄存器BX中的送入AX中add ax,bx   #将AX和BX中的数值相加，并存在AX中</code></pre><h3 id="4-物理地址"><a href="#4-物理地址" class="headerlink" title="4.物理地址"></a>4.物理地址</h3><p>8086cpu是16位结构的cpu，具有下面几方面的结构特性</p><ul><li>运算器依次最多可以处理16位的数据</li><li>寄存器的最大宽度为16位</li><li>寄存器和运算器之间的通路为16位</li></ul><br/><p>8086CPU有20位地址总线，可以传送20位地址，达到1MB的寻址能力</p><p>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址，当8086CPU要读写内存时：</p><p>(1)CPU中相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址</p><p>(2)段地址和偏移地址通过内部总线送入一个称为地址加法器的部件</p><p>(3)地址加法器将两个16位地址合成一个20位的物理地址</p><p>(4)地址加法器通过内部总线将20位的物理地址</p><p>(5)输入输出控制电路将20位物理地址送上地址总线</p><p>(6)20位物理地址被地址总线传送到储存器</p><p>地址加法器采用 <strong>物理地址 &#x3D; 段地址 * 16 + 偏移地址</strong>的方法用段地址和偏移地址合成物理地址</p><p>这段公式的本质含义是：CPU访问内存时，用一个基础地址（段地址*16）和一个相对于基础地质的偏移地址相加，给出内存单元的物理地址</p><br/><h3 id="5-段寄存器"><a href="#5-段寄存器" class="headerlink" title="5.段寄存器"></a>5.段寄存器</h3><p>8086CPU有4个段寄存器：CS,DS,SS,ES</p><h3 id="6-CS和IP"><a href="#6-CS和IP" class="headerlink" title="6.CS和IP"></a>6.CS和IP</h3><p>CS和IP是8086CPU中最重要的两个寄存器，其中，CS是代码寄存器，IP是指令指针寄存器</p><p>设CS中的内容为M，IP中的内容为N，8086CPU将从内存M*16+N单元开始，读取一条指令并执行（任意时刻，CS:IP指向的内容当做指令执行）</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/HB2.png?raw=true"></p><p>通过上面的过程，8086CPU的工作过程可以简要描述成：</p><p>(1)从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器</p><p>(2)IP &#x3D; IP + 所读取指令的长度，从而指向下一条指令</p><p>(3)执行指令。转到步骤1，重复这个过程</p><p><strong>修改CS，IP的指令</strong></p><p>mov不能用于设置CS:IP的值，如果想同时修改CS:IP的内容，可用形如<strong>“jmp 段地址:偏移地址”</strong>的指令完成，如：</p><pre><code class="highlight assembly">jmp 2AE3:3   #执行后:CS=2AE3H ,IP=0003h ,CPU将从2AE33H处读取指令jmp 3:0B16   #执行后:CS=0003H ,IP=0B16H ,CPU将从00B46H处读取指令</code></pre><p>“jmp 段地址:偏移地址”指令的功能为：用指令中给出的段地址修改CS，偏移地址修改IP</p><p>若想仅修改IP的内容，可以用形如”jmp 某一合法寄存器”的指令完成</p><pre><code class="highlight assembly">jmp ax    #指令执行前：ax=1000h,CS=2000H,IP=0003H #指令执行后: ax=1000H,CS=2000H,IP=0B16H</code></pre><p>在含义上，好似”mov IP ax”</p><hr><h2 id="Debug模式"><a href="#Debug模式" class="headerlink" title="Debug模式"></a>Debug模式</h2><p>debug是Dos,Windows都提供的实模式（8086方式）程序的调试工具</p><p>会经常用到的Debug功能:</p><ul><li>R命令查看，改变CPU寄存器的内容</li><li>D命令查看内存中的内容</li><li>E命令改写内存中的内容</li><li>U命令将内存中的机器指令翻译成汇编指令</li><li>T命令执行一条机器指令</li><li>A命令以汇编指令的格式在内存中写入一条机器命令</li></ul><p>-r指令，-r 寄存器,即可修改寄存器中的内容</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/HB8.png?raw=true"></p><p>如图，输入指令后，会提示当前AX中的内容，用一个冒号提示修改后的值，即可修改</p><br/><p>-d 查看内存中的内容，如图</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/HB9.png?raw=true"></p><br/><p>输入-a后，即可以在内存中输入汇编指令</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/HB10.png?raw=true"></p><p>可以看见，已经切换到某个内存单元中去了</p><p>输入</p><pre><code class="highlight assembly">mov ax,4e20add ax,1416mov bx,2000add ax,bxmov bx,axadd ax,bxmov ax,001Amov bx,0026add al,bladd ah,bladd bh,almov ah,0add al,bladd al,9c</code></pre><p>输入-u 138c:0100即可查询到刚刚输入的汇编代码</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/HB11.png?raw=true"></p><hr><h2 id="寄存器（内存访问）"><a href="#寄存器（内存访问）" class="headerlink" title="寄存器（内存访问）"></a>寄存器（内存访问）</h2><h3 id="字单元"><a href="#字单元" class="headerlink" title="字单元"></a>字单元</h3><p>字单元，及存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。我们将起始地址为N的字单元简称为N地址字单元。</p><h3 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h3><pre><code class="highlight assembly">mov bx,1000Hmov ds,bxmov al,[0]</code></pre><p>上面的3条指令将10000H(1000:0)中的数据读到al中</p><p>其中[…]表示一个内存单元，[…]中的0表示内存单元的偏移地址，程序执行时候8086CPU自动取ds中的数据作为段地址</p><h3 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h3><pre><code class="highlight assembly">mov bx,1000Hmov ds,bxmov al,[0]mov [0],cx                ;cx中的16位数据送到1000:0处</code></pre><h3 id="mov-add-sub指令"><a href="#mov-add-sub指令" class="headerlink" title="mov,add,sub指令"></a>mov,add,sub指令</h3><p>add和sub指令同mov一样，都有两个操作对象。他们也可以有一下几种形式</p><pre><code class="highlight assembly">add 寄存器,数据add 寄存器,寄存器add 寄存器,内存单元add 内存单元,寄存器sub 寄存器,数据sub 寄存器,寄存器sub 寄存器,内存单元sub 内存单元,寄存器</code></pre><h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将一组长度为N(N&lt;&#x3D;64KB)，地址连续，起始地址为16倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。可以在具体操作的时候，用ds存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元</p><pre><code class="highlight assembly">mov ax,123BHmov ds,axmov ax,0                ;用ax存放累计结果add ax,[0]              ;将数据段第一个字(偏移地址为0)，加到ax中add ax,[2]              ;将数据段第二个字(偏移地址为2)，加到ax中add ax,[4]              ;将数据段第三个字(偏移地址为4)，加到ax中</code></pre><p>注意，一个字型数据占两个单元，所以偏移地址是0,2,4</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h3><p>进出规则为：“Last In First Out”(后进先出)</p><p>PUSH进栈指令 POP出栈指令</p><p>栈操作示意：</p><pre><code class="highlight assembly">mov ax,0123Hpush axmov bx,2266Hpush bxmov cx,1122Hpush cxpop axpop bxpop cx</code></pre><p>注：字型数据用两个单元存放，高地址单元存放高8位，低地址单元存放低8位</p><p>8086cpu中，有两个寄存器，段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中</p><p><strong>任意时刻，SS:SP指向栈顶元素</strong>push指令和pop指令执行时，CPU从SS和SP中得到栈顶的位置，但是当栈空的时候，栈中没有元素，也就不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2，栈最底部字单元的地址为1000:000E,所以栈空时，SP&#x3D;0010H</p><p>pop指令的执行过程和push刚好相反，由以下两步完成</p><p>(1)将SS:SP指向的内存单元处的数据送入ax中</p><p>(2)SP&#x3D;SP+2,SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</p><h3 id="栈顶超界问题"><a href="#栈顶超界问题" class="headerlink" title="栈顶超界问题"></a>栈顶超界问题</h3><p>栈顶超界是危险的，如果我们在入栈出栈的时候不小心，而将这些数据，代码意外地改写，将会引发一系列的错误</p><h3 id="PUSH和POP指令"><a href="#PUSH和POP指令" class="headerlink" title="PUSH和POP指令"></a>PUSH和POP指令</h3><pre><code class="highlight assembly">push 寄存器/段寄存器/内存单元                 ;将一个寄存器/段寄存器/内存单元中的数据入栈pop 寄存器/段寄存器/内存单元  ;出栈，用一个寄存器/段寄存器/内存单元接收出栈的数据</code></pre><p>我们也可以使用push和pop在内存单元和内存单元之间传送数据</p><pre><code class="highlight assembly">push 内存单元      ;将一个内存字单元处的字入栈（注：栈操作都是以字为单位）pop 内存单元       ;出栈，出战的数据送入1000:2处</code></pre><p>CPU要知道内存单元的地址，可以在push，pop指令中只给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中获得</p><p>注：push，pop等栈操作指令，修改的只是SP。也就是说，栈顶变化范围最大为：0~FFFFH</p><p>栈的综述：</p><p>(1)栈根据SS:SP指示的地址以栈的方式访问内存</p><p>(2)push指令的执行步骤:1.SP&#x3D;SP-2 向SS:SP指向的字单元送入数据</p><p>(3)pop：SP&#x3D;SP+2,也是从SS:SP指向的的字单元中读取数据</p><h3 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h3><p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元</p><pre><code class="highlight assembly">mov ax 1000Hmov ss,axmov sp,0020H             ;初始化栈项mov ax,csmov ds,ax                ;设置数据段段地址mov ax,[0]add ax,[2]mov bx,[4]add bx,[6]push axpush bxpop axpop bx</code></pre><h2 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h2><pre><code class="highlight assembly">assume cs:codesgcodesg segmentmov ax,0123Hmov bx,0456Hadd ax,bxadd ax,axmov ax,4c00HINT 21Hcodesg endsend</code></pre><p>其中assume cs:codesg是把codesg与cs寄存器连接起来</p><p>sagement表示以codesg为名称的段开始</p><p>codesg ends表示codesg段结束</p><p>end表示整个汇编函数结束</p><pre><code class="highlight assembly">mov ax,4c00Hint 21H</code></pre><p>实现的是程序返回(调用了INT 21H的4CH号中断)</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><hr><h2 id="BX-和loop命令"><a href="#BX-和loop命令" class="headerlink" title="[BX]和loop命令"></a>[BX]和loop命令</h2><p>[bx]表示一个内存单元，它的偏移地址在bx中，比如：</p><pre><code class="highlight assembly">mov ax,[bx]</code></pre><p>将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址在bx中，段地址在ds中</p><p><strong>loop</strong>意为循环，这个函数和循环有关</p><h3 id="BX"><a href="#BX" class="headerlink" title="[BX]"></a>[BX]</h3><pre><code class="highlight assembly">mov bx,1inc bx              ;bx的内容+1</code></pre><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/HB4.png?raw=true"></p><h3 id="Loop指令"><a href="#Loop指令" class="headerlink" title="Loop指令"></a>Loop指令</h3><p>loop指令的格式：loop标号，CPU执行loop指令时，要进行两步操作</p><p>1.(cx)&#x3D;(cx)-1</p><p>2.判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行</p><p>例：</p><p>假如说我们要进行计算2^3(2*2*2),那么可以这样实现</p><pre><code class="highlight assembly">assume cs:codecode segmentmov ax,2add ax,axadd ax,axmov ax,4C00HINT 21Hcode endsend</code></pre><p>那如果要计算2^10,如果直接进行计算，那么重复次数就有点多了，可以用loop指令来化简</p><pre><code class="highlight assembly">assume cs:codecode segmentmov ax,2mov cx,10              ;循环次数s: add ax,ax               ;定义标号sloop s                 ;循环smov ax,4C00HINT 21Hcode endsend</code></pre><p>cx是循环计数寄存器，所以循环次数的值写入cx中</p><p>如果我们在debug中追踪循环的值，如果循环次数过大，我们要用相对应次数的t命令才能从循环中出来，所以我们可以用p命令来一次性完成循环的内容</p><h3 id="loop和-bx-的联合使用"><a href="#loop和-bx-的联合使用" class="headerlink" title="loop和[bx]的联合使用"></a>loop和[bx]的联合使用</h3><p>如果计算ffff:0~ffff:b单元中数据的和，结果存储在dx中</p><p>有两种方法</p><ul><li>(dx)&#x3D;(dx)+内存中的8位数据；</li><li>(dl)&#x3D;(dl)+内存中的8位数据。</li></ul><p>但是，第一种方法两个运算对象不匹配，第二种方法是可能会超界</p><p>可以用一个16位寄存器作为中介，编写以下程序</p><pre><code class="highlight assembly">assume cs:codecode segmentmov ax,0ffffhmov ds,axmov dx,0               ;初始化累加寄存器，(dx)=0mov al,ds:[0]          mov ah,0               ;(ax)=((ds)*16+0)=(ffff0h)add dx,ax              ;向dx中加上ffff:0单元的数值mov al,ds:[1]mov ah,0                ;(ax)=((ds)*16+1)=(ffff1h)add dx,ax               ;向dx中加上ffff:1单元的数值...mov al,ds:[0bs]mov ah,0                 ;(ax)=((ds)*16+0bh)=(ffffbh)add dx,ax                ;向dx中加上ffff:b单元的数值</code></pre><p>程序写得很长，为了简化，我们可以用数学语言来描述这个累加的运算</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/HB5.png?raw=true"></p><p>用程序运行可以描述成这样：</p><pre><code class="highlight plaintext">s:(a1)=((ds)*16+(bx))  (ah)=0  (dx)=(dx)+(ax)  (bx)=(bx)+1  loop s</code></pre><p>最后，程序可以改成这样</p><pre><code class="highlight assembly">assume cs:codecode segmentmov ax,0ffffhmoc ds,axmov bx,0            ;初始化ds:bx指向ffff:0mov dx,0            ;初始化累加寄存器,dx,(dx)=0mov cx,12           ;初始化循环计数寄存器cx,(cx)=12s: mov a1,[bx]mov ah,0add dx,ax            ;间接向dx中加上((ds)*16+(bx))单元的数值inc bx               ;ds:bx指向等下一个单元loop smov ax,4c00hint 21hcode endsend</code></pre><h3 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h3><p>顾名思义，就是可以为偏移地址加上段前缀</p><p>例：mov ax,ds:[bx]意为：将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址在bx中，段地址在ds中</p><h3 id="一段安全的空间"><a href="#一段安全的空间" class="headerlink" title="一段安全的空间"></a>一段安全的空间</h3><p>在8086中，随意向一段空间写入内容是很危险的，因为这段空间可能存放着重要的系统数据或者代码，从而引发报错</p><p>如下面这一串代码</p><pre><code class="highlight assembly">assume cs:codecode segmentmov ax,0mov ds,axmov ds:[26h],axmov ax,4c00hint 21hcode endsend</code></pre><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/HB6.png?raw=true"></p><p>可以看到源程序经过masm翻译，再经过debug解释，最后得到的是”mov [0026],ax”</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/HB7.png?raw=true"></p><p>发生了报错，如果是在原生dos模式下则会发生死机，可见，不能确定一段内存空间中是否存放盒重要数据或代码的时候，不能随意向里面写入内容</p><ul><li>DOS模式下，一般情况，0:200<del>0:2ff这段空间没有系统或其他程序的数据或代码，所以我们需要往内存里面写内容时，就用0:200</del>0:2ff这段空间</li></ul><h2 id="包含多个段的程序"><a href="#包含多个段的程序" class="headerlink" title="包含多个段的程序"></a>包含多个段的程序</h2><h3 id="在代码段使用数据"><a href="#在代码段使用数据" class="headerlink" title="在代码段使用数据"></a>在代码段使用数据</h3><p>将以下8个数据的和，结果存在ax寄存器中：</p><p>0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</p><pre><code class="highlight assembly">assume cs:codecode segmentdw 0123h,0456h,......,0987hmov bx,0mov ax,0mov cx,8s:add ax,cs:[bx]add bx,2loop smov ax,4c00hint 21hcode endsend</code></pre><p>程序中第一行中的”dw”的含义是定义字型数据。dw即define word,在这里，使用dw定义了8个字型数据，占用内存空间大小为16个字节(每个数据占2个字节)</p><h3 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h3><pre><code class="highlight assembly">dw 0123h,0456h,.....,0987hdw 0,0,0,...,0;用dw定义16个字型数据，在程序加载后取得这16个字型数据的内存空间，存放这些数据;后面的程序将使用这段空间当做栈来使用</code></pre><h3 id="将数据，代码，栈放入不同的段"><a href="#将数据，代码，栈放入不同的段" class="headerlink" title="将数据，代码，栈放入不同的段"></a>将数据，代码，栈放入不同的段</h3>]]></content>
      
      
      <categories>
          
          <category> 周报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考核题目复现</title>
      <link href="/2024/10/26/%E8%80%83%E6%A0%B8%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/"/>
      <url>/2024/10/26/%E8%80%83%E6%A0%B8%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>第一道题目， 使用指针创建一个二维整型数组，并通过用户输入初始化数组的元素。然后计算并输出所有元素的和</p><p>要求输入示例</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/HD/ERR1.png?raw=true"></p><p>刚开始尝试实现的结果是这样的<br><img src="https://github.com/SUDG01/tuchuang/blob/main/HD/ERR2.png?raw=true"></p><p>很疑惑，为什么结果会多出来10，换了几个数字和数组大小，结果总是和预期不同</p><p>猜测可能是访问越界，导致访问数组的值不正确</p><p>通过搜索得知，二维数组涉及到一个动态分配的问题</p><pre><code class="highlight c"><span class="type">int</span>** arr = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*)* hang);         <span class="comment">//申请一个二级指针，用来记录有多少个指向整型的指针。行数</span><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; hang;i++)&#123;    arr[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)* lie);           <span class="comment">//循环，为每行分配列数的内存</span>&#125;</code></pre><p>其中，int**是指向整个一维数组的指针，即整个二维数组，int*则是指向一维数组</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/HD/fixed1.png?raw=true"></p><p>将动态分配加上后，果然，数值计算就正确了</p><hr><p>而第二道题目</p><p>编写一个C程序,使用指针创建一个一维数组,并通过用户输入初始化数组的元素,然后通过计算每个元素(大写，小写,空格，数字)出现的次数</p><p>要求：</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/HD/ERR3.png?raw=true"></p><p>一开始，我使用的是scanf，却忽略了一点，scanf(“%s”)只能接收字符串，不能接收空格等内容，导致无法成功统计</p><p>换了gets_s后就正常运行了，但是gets_s限制的长度理应是只要不超过即可，但是限制的值太大又会导致无法输出</p><p>于是我又尝试了fgets,然后输出就正常了</p><pre><code class="highlight c">fgets(str1,<span class="number">128</span>,<span class="built_in">stdin</span>);</code></pre><p><img src="https://github.com/SUDG01/tuchuang/blob/main/HD/fixed2.png?raw=true"></p><hr><p>题目3</p><p>编写一个C程序，通过文件指针创建一个input.txt，并且向里面写入YYDDHel，后面读取input.txt并且把每个字符转化成二进制，并且将每个字符循环右移它的索引值</p><p>要求</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/HD/ERR4.png?raw=true"></p><p>思路是有，但是移位实现有点迷糊</p><p>一开始有数据溢出现象，memset后，再调整一下限制，就解决了，可以正常打印2进制</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/HD/unfix1.png?raw=true"></p><p>现在需要的就是将数据移位它的索引值的数量，由题可以看出来是左移</p><p>搜索后得到一个思路，可以分别将值右移n位，再将值位移8-n位（YYDDHell长度为8），然后用或(|)运算将两个位移过后的数合并，最后得到值</p><p>于是用了一个函数来实现</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/HD/fixed3.png?raw=true"></p>]]></content>
      
      
      <categories>
          
          <category> solved </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习</title>
      <link href="/2024/10/07/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/10/07/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="学习C语言"><a href="#学习C语言" class="headerlink" title="学习C语言"></a>学习C语言</h1><h2 id="一-PE格式"><a href="#一-PE格式" class="headerlink" title="一.PE格式"></a>一.PE格式</h2><h3 id="1-PE文件"><a href="#1-PE文件" class="headerlink" title="1.PE文件"></a>1.PE文件</h3><p>在win下：.exe .dll .sys</p><p>在linux下： elf</p><p>此类文件都属于PE结构的文件类型。</p><h3 id="2-PE文件的构成"><a href="#2-PE文件的构成" class="headerlink" title="2.PE文件的构成"></a>2.PE文件的构成</h3><p>由DOS部首，PE文件头，块表（section table）,块（section）以及调试信息组成</p><h4 id="DOS部首"><a href="#DOS部首" class="headerlink" title="DOS部首"></a>DOS部首</h4><p>最开始的部分是DOS部首，由DOS的MZ文件标志和DOS stub组成</p><p>（MZ）开头: e_magic ，为固定的值 “0x5a4d”</p><p>DOS Stub即为一句话”This program Cannot be run in DOS mode”</p><h4 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h4><p>最开始的部分是以’PE\0\0’:”0x50 0x45 00 00”开始的，由DOS部首中，结构成员e_lfanew(0x3c)指向</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs1.png?raw=true"></p><p>在PE文件头中，IMAGE_OPTIONAL_HEADER32和IMAGE_FILE_HEADER都定义了很多PE的数据</p><p>特别在IMAGE_OPTIONAL_HEADER32中，包含了数据结构表</p><p>数据结构表有导出表和导入表</p><p>导入表为引用的函数，导出表则为程序本身定义的函数</p><h4 id="块表"><a href="#块表" class="headerlink" title="块表"></a>块表</h4><p>块表指向块</p><h4 id="块"><a href="#块" class="headerlink" title="块"></a>块</h4><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs2.png?raw=true"></p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs3.png?raw=true"></p><p>RVA(相对虚拟地址)&#x3D; VA(虚拟地址) - ImageBase(起始地址)</p><p>VOFFSET &#x3D; 每个节的虚拟地址 - 起始地址</p><p>ROFFSET &#x3D; 每个节的虚拟地址 - 每个文件的首地址</p><h2 id="二-进制转换"><a href="#二-进制转换" class="headerlink" title="二.进制转换"></a>二.进制转换</h2><h3 id="1-表现形式"><a href="#1-表现形式" class="headerlink" title="1.表现形式"></a>1.表现形式</h3><p>在C语言中：16进制为0x开头，如（0x71ef）,x可以为大小写</p><p>在汇编语言中：</p><p>16进制为H结尾，如：（1aH）</p><p>八进制为O结尾，如：（17O）</p><p>十进制为D结尾，如：（12D）</p><p>二进制为B结尾，如：（110B）</p><h3 id="2-转换"><a href="#2-转换" class="headerlink" title="2.转换"></a>2.转换</h3><p><img src="https://github.com/SUDG01/tuchuang/blob/main/jinzhi1.png?raw=true"></p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/jinzhi2.png?raw=true"></p><p>计算方法。。。。。。</p><h3 id="3-整数编码"><a href="#3-整数编码" class="headerlink" title="3.整数编码"></a>3.整数编码</h3><p>表格法：1024 512 256 128 64 32 16 8 4 2 1 可以计算整数的原码</p><p>计算机使用补码</p><p>补码中负数等于绝对值的原码取反加一</p><h3 id="4-整数的存储方式"><a href="#4-整数的存储方式" class="headerlink" title="4.整数的存储方式"></a>4.整数的存储方式</h3><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs4.png?raw=true"></p><p>但是，x86（32位）系统则为低位优先，按图，则是78 56 34 12</p><h3 id="5-浮点数的定义和储存"><a href="#5-浮点数的定义和储存" class="headerlink" title="5.浮点数的定义和储存"></a>5.浮点数的定义和储存</h3><pre><code class="highlight c"><span class="type">float</span> x = <span class="number">1.732f</span>;<span class="type">double</span> y = <span class="number">3.1415926</span>;</code></pre><p>浮点数需要在常数后面加f声明为浮点数，双精度则不需要</p><p>单精度在二进制存储当中阶码部分占用8位，小数部分中占用23位</p><p>双精度在二进制存储当中阶码部分占用11位，小数部分中占用52位，两种精度都各保留一位符号位</p><p>0为正数，1为负数</p><h2 id="三-C语言中数据的类型"><a href="#三-C语言中数据的类型" class="headerlink" title="三.C语言中数据的类型"></a>三.C语言中数据的类型</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p>字符类型： char (ASCLL字符) &#x2F; wchar_t (UNICODE字符)  UNICODE字符需要在值前加L来声明</p><p>整型： short&#x2F;int&#x2F;long&#x2F;long long&#x2F;_int64</p><p>实数：单精度float  ，双精度double</p><p>有符号和无符号：signed&#x2F;unsigned, (signed)int&#x2F;(unsigned) int</p><p>布尔类型：bool , 0&#x2F;1(true&#x2F;false),C99&lt;stdbool.h&gt; </p><h3 id="2-Ascll编码"><a href="#2-Ascll编码" class="headerlink" title="2.Ascll编码"></a>2.Ascll编码</h3><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Ascall.png?raw=true"></p><p>其中英文大写和小写之间的差值为32，可以用代码表示为</p><pre><code class="highlight c"><span class="type">char</span> c = <span class="string">&#x27;M&#x27;</span>;c + <span class="string">&#x27;a&#x27;</span>-<span class="string">&#x27;A&#x27;</span>;<span class="comment">//大写转小写</span><span class="type">char</span> d = <span class="string">&#x27;m&#x27;</span>;d + <span class="string">&#x27;A&#x27;</span>-<span class="string">&#x27;a&#x27;</span><span class="comment">//小写转大写</span></code></pre><h3 id="3-整型"><a href="#3-整型" class="headerlink" title="3.整型"></a>3.整型</h3><p>int 和long int(long)占4个字节，long在linux里占8个字节</p><p>longlong（gc） 和 _int64（vc）占8个字节</p><p>bool的长度为1个字节，BOOL为4个字节</p><pre><code class="highlight c"><span class="type">long</span> a = <span class="number">100L</span>;<span class="type">unsigned</span> <span class="type">long</span> b = <span class="number">100UL</span>;<span class="type">long</span> <span class="type">long</span> c = <span class="number">100ll</span>;        <span class="comment">//linux</span>_int64 d = <span class="number">100</span>i64;          <span class="comment">//windows</span></code></pre><h3 id="4-自定义新的类型"><a href="#4-自定义新的类型" class="headerlink" title="4.自定义新的类型"></a>4.自定义新的类型</h3><pre><code class="highlight c"><span class="keyword">typedef</span> <span class="type">int</span> INT<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> UINT             <span class="comment">//重新定义类型，好处简洁，同一编码风格，容易在其他平台改动</span></code></pre><h3 id="5-范围"><a href="#5-范围" class="headerlink" title="5.范围"></a>5.范围</h3><p>char [0,255]，8位， short [0,65535] 16位</p><p>int [0,4294967295] 32位 </p><p>以上均为无符号，有符号范围则是 [ -2 ^(n-1),2^(n-1)-1 ]</p><p>*在linux中，超级用户的GID为0（数据溢出，即如果超过可表示的范围则从负数开始计算）</p><h3 id="6-类型转换"><a href="#6-类型转换" class="headerlink" title="6.类型转换"></a>6.类型转换</h3><p>强制转换，人为使变量的类型发生转变，用例：</p><pre><code class="highlight c"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;<span class="comment">//原类型</span><span class="type">short</span> i = (<span class="type">short</span>)c;             <span class="comment">//转换</span></code></pre><p>浮点数到整数，如：</p><pre><code class="highlight c"><span class="type">int</span> i = (<span class="type">int</span>)<span class="number">3.14</span>;<span class="type">int</span> b = (<span class="type">int</span>)<span class="number">3.74</span>;                       <span class="comment">//两个结果均为3，只取整，并不会四舍五入</span></code></pre><p>如果从大到小转换</p><pre><code class="highlight c"><span class="type">int</span> x = <span class="number">0x12345678</span>;<span class="type">short</span> y = (<span class="type">short</span>)x;</code></pre><p>数据会从高位开始截断，如上，int为4个字节的数据，而short为两个字节，所以，y的值则会是<strong>0x5678</strong></p><p>自动转换，遵循一个规则，所有运算中，必须全部转换成同一种类型的数据再进行运算</p><p>且自动转换是以运算中最长的一种类型统一转换</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs5.png?raw=true"></p><p>单精度转双精度则是通过截尾来实现，会丢失一定量的数据（要进行四舍五入操作）</p><p>若signed整型赋给长度相同的unsigned型变量，内部存储形式不变，但外部表示时总是无符号的</p><pre><code class="highlight c"><span class="type">short</span> s = <span class="number">-1</span>;<span class="type">unsigned</span> <span class="type">short</span> us =(<span class="type">unsigned</span> <span class="type">short</span>)s;us = <span class="number">65535</span></code></pre><h2 id="四-变量"><a href="#四-变量" class="headerlink" title="四.变量"></a>四.变量</h2><h3 id="1-变量命名和定义"><a href="#1-变量命名和定义" class="headerlink" title="1.变量命名和定义"></a>1.变量命名和定义</h3><p>命名原则:只能由字母，下划线和数字组成，但第一个字符必须为字母，下划线也被看做为字母，且不能用关键字来当做变量，大写字符一般用于定义常量</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs6.png?raw=true"></p><p>命名规则（例：匈牙利命名）</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs8.png?raw=true"></p><p>一般有4种命名方法：匈牙利，下划线（linux），驼峰，帕斯卡</p><pre><code class="highlight c"><span class="type">int</span> iMyData;     <span class="comment">//匈牙利</span><span class="type">int</span> my_data;     <span class="comment">//下划线</span><span class="type">int</span> myData;      <span class="comment">//驼峰</span><span class="type">int</span> MyData;      <span class="comment">//帕斯卡</span></code></pre><h3 id="2-变量类型"><a href="#2-变量类型" class="headerlink" title="2.变量类型"></a>2.变量类型</h3><p>共有：全局变量，全局静态变量，局部变量，局部静态变量，寄存器变量5种</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs7.png?raw=true"></p><h2 id="五-开始使用"><a href="#五-开始使用" class="headerlink" title="五.开始使用"></a>五.开始使用</h2><h3 id="1-输入与输出"><a href="#1-输入与输出" class="headerlink" title="1.输入与输出"></a>1.输入与输出</h3><p>使用scanf函数接收输入</p><p>用法(例)</p><pre><code class="highlight c"><span class="type">int</span> C;<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);              <span class="comment">//warning:4996,可能会出现安全问题，可使用scanf_s()</span><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,c);</code></pre><p>在连续两个接收数据时，因为用户按下了回车，而回车也会当做一个字符，所以会导致后面的接收被顶掉，所以应该在每次scanf后输入：</p><pre><code class="highlight c">fflush(<span class="built_in">stdin</span>);                  <span class="comment">//清空数据缓存区域</span><span class="comment">//或者</span><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>,%c);                <span class="comment">//在%c前加一个空格</span></code></pre><p>还有其他接收字符的函数,例：</p><pre><code class="highlight c"><span class="type">char</span> a = getch();              <span class="comment">//检测输入后自动下一步</span><span class="type">char</span> a1 = getchar();           <span class="comment">//等待回车</span></code></pre><p>也可以用_getch()代替</p><p>%号后面的值：(tips: hd &#x3D;短整型，ld &#x3D; 长整型，I64d &#x3D; _int64的整数)</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs9.png?raw=true"></p><p>浮点数tip: %.[数字]可以控制浮点数后面有几位小数</p><p>字符串：</p><pre><code class="highlight c">gets();                          <span class="comment">//可以用gets_s()代替</span><span class="built_in">puts</span>();                          <span class="comment">//可以避免scanf以空格结束的问题</span></code></pre><p>文件流: stdin(输入)，stdout(输出)，stderr(错误)</p><h3 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h3><p>()优先级最高，优先算括号内数</p><p>逻辑非! : !0&#x3D;1，!非零 &#x3D; 0    </p><p>自增，自减: i++,++i,i–,–i</p><p>i++和++i的区别</p><pre><code class="highlight c"><span class="type">int</span> i = <span class="number">0</span>;<span class="type">int</span> a = i++;                  <span class="comment">//先i=a,在i+1</span><span class="type">int</span> b = ++i;                  <span class="comment">//先i+1,再i=b</span></code></pre><p>&amp;&amp;(逻辑与，且)，||(逻辑或)，&amp;&amp;的优先级大于||</p><p>?：取两个数的最大值</p><pre><code class="highlight c">a&lt;b?a:b                   <span class="comment">//如果前式为真，则取a，为否，则取b</span></code></pre><p>,运算符是优先级最低的</p><p>贪心算法：</p><p>编译器从左到右开始对运算符号依次读取，直到无法再组成一个新的运算式，例</p><pre><code class="highlight c">a+++++b;                  <span class="comment">//解析结果为((a++)++)+b</span></code></pre><h3 id="3-随机数"><a href="#3-随机数" class="headerlink" title="3.随机数"></a>3.随机数</h3><p>rand函数，但是需要随机生成一个种子，用例（一百以内的随机数）：</p><pre><code class="highlight c">srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="number">0</span>));               <span class="comment">//取当前时间为随机数的种子</span><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++);&#123;    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,rand()%<span class="number">100</span>);                 <span class="comment">//除以100的余数，即余数小于100，得到100以内的随机数</span>&#125;</code></pre><h3 id="4-switch语句"><a href="#4-switch语句" class="headerlink" title="4.switch语句"></a>4.switch语句</h3><p>与if语句使用方法类似，下面为例：</p><pre><code class="highlight c"><span class="keyword">switch</span>()&#123;<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>;    <span class="keyword">do</span> something;<span class="keyword">break</span>;                      <span class="comment">//如果没有加break的话，语句会继续往下执行而不会跳出switch函数</span><span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>;    <span class="keyword">do</span> something;    <span class="keyword">break</span>;...&#125;</code></pre><h3 id="5-循环"><a href="#5-循环" class="headerlink" title="5.循环"></a>5.循环</h3><p>for()语句由三个部分组成( 初始化变量 ;  判断条件; 更新循环变量表达式 )</p><p>do while 循环</p><pre><code class="highlight c"><span class="keyword">do</span>                <span class="comment">//int i = 0 </span>&#123;    <span class="built_in">printf</span>(<span class="string">&quot;balabala&quot;</span>);    i++;&#125;<span class="keyword">while</span> (i&lt;<span class="number">10</span>);                             <span class="comment">//与while循环不同的是，是先执行，再进行判断</span></code></pre><h3 id="6-转向语句"><a href="#6-转向语句" class="headerlink" title="6.转向语句"></a>6.转向语句</h3><h4 id="1-goto语句-常用于出错处理，跳出多重循环，慎用"><a href="#1-goto语句-常用于出错处理，跳出多重循环，慎用" class="headerlink" title="1.goto语句(常用于出错处理，跳出多重循环，慎用)"></a>1.goto语句(常用于出错处理，跳出多重循环，慎用)</h4><pre><code class="highlight c"><span class="keyword">goto</span> L1;...L1;语句语句</code></pre><p>tip: 如果申请内存使用后不再需要，要记得free()释放内存，防止内存泄漏</p><h4 id="2-break和continue"><a href="#2-break和continue" class="headerlink" title="2.break和continue"></a>2.break和continue</h4><p>break函数用于退出循环，return用于退出整个函数,并提供返回值</p><p>continue用于进入下一次循环，当执行到continue语句时，当前循环语句将不会继续进行</p><h2 id="六-数组"><a href="#六-数组" class="headerlink" title="六.数组"></a>六.数组</h2><h3 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1.一维数组"></a>1.一维数组</h3><h4 id="1-随机访问-数组中每个数代表4个字节，那么就可以做到："><a href="#1-随机访问-数组中每个数代表4个字节，那么就可以做到：" class="headerlink" title="1.随机访问,数组中每个数代表4个字节，那么就可以做到："></a>1.随机访问,数组中每个数代表4个字节，那么就可以做到：</h4><pre><code class="highlight c"><span class="type">int</span> a[<span class="number">10</span>];               <span class="comment">//假如要访问数组中第6个值</span>a[<span class="number">0</span>]+<span class="number">20</span>;                 <span class="comment">//加20得到的即为第六个值的地址</span></code></pre><h4 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h4><pre><code class="highlight c"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;<span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;                         <span class="comment">//没有初始化的值均为0</span><span class="type">int</span> a[<span class="number">10</span>] = &#123;(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">3</span>),<span class="number">4</span>&#125;                     <span class="comment">//逗号表达式，结果等价于&#123;1,3,4&#125;</span><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;                                 <span class="comment">//全部初始化为0</span><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</code></pre><h4 id="3-字符数组"><a href="#3-字符数组" class="headerlink" title="3.字符数组"></a>3.字符数组</h4><pre><code class="highlight c"><span class="type">char</span> str1[] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;;<span class="type">char</span> str2[] = <span class="string">&quot;hello&quot;</span>；                    <span class="comment">//看起来相同，但是str2比str1多1个\0作为结束符</span></code></pre><p>tip:数组名是常量指针，一旦定义，就不能修改，如：</p><pre><code class="highlight c"><span class="type">char</span> a[<span class="number">100</span>];a = <span class="string">&quot;hello world&quot;</span>                          <span class="comment">//error</span></code></pre><h3 id="2-二维数组"><a href="#2-二维数组" class="headerlink" title="2.二维数组"></a>2.二维数组</h3><p>定义方式：(因为量大，不好直接写，直接放图)</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs10.png?raw=true"></p><p>初始化：</p><pre><code class="highlight c"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">23</span>,<span class="number">34</span>,<span class="number">21</span>&#125;,&#123;<span class="number">72</span>,<span class="number">2</span>,<span class="number">31</span>&#125;,&#123;<span class="number">123</span>,<span class="number">23</span>,<span class="number">5</span>&#125;,...&#125;;</code></pre><h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h3><p>在数组中，如果有整数型数组a1[5]&#x3D;{0};     a2[3][4]&#x3D;{0}；假设a1的起始地址为:10000000,a2的起始地址为200000000</p><p>对数组进行+1操作可以得到：</p><pre><code class="highlight c">a1 + <span class="number">1</span> = <span class="number">100000004</span>;           &amp;a1 + <span class="number">1</span> = <span class="number">200000020</span>;a2 + <span class="number">1</span> = <span class="number">100000016</span>;           &amp;a2 + <span class="number">1</span> = <span class="number">200000048</span>;</code></pre><p>在数组中，一行算一个元素，一个元素4个字节，a1+1的值则加一个元素，而&amp;a1为数组的地址，则加一整个地址，有5个元素，则加4*5&#x3D;20</p><p>a2有4行，算4个元素，则a2+1的地址加16，&amp;a2则有总共12个元素，则地址加3*4*4&#x3D;48</p><p>&#x2F;&#x2F;P26 30:30</p><h4 id="数组的溢出"><a href="#数组的溢出" class="headerlink" title="数组的溢出"></a>数组的溢出</h4><p>C编译器对数组溢出不做检测<br>程序在运行时候，数组溢出导致程序行为未定义</p><h3 id="4-数组的应用"><a href="#4-数组的应用" class="headerlink" title="4.数组的应用"></a>4.数组的应用</h3><h4 id="1-计算斐波那契数组"><a href="#1-计算斐波那契数组" class="headerlink" title="1.计算斐波那契数组"></a>1.计算斐波那契数组</h4><p><img src="https://github.com/SUDG01/tuchuang/blob/main/flpq_math.png?raw=true"></p><h4 id="2-字符串大小写转换"><a href="#2-字符串大小写转换" class="headerlink" title="2.字符串大小写转换"></a>2.字符串大小写转换</h4><p><img src="https://github.com/SUDG01/tuchuang/blob/main/transtr.png?raw=true"></p><h4 id="3-计算平均值"><a href="#3-计算平均值" class="headerlink" title="3.计算平均值"></a>3.计算平均值</h4><p>定义一个数组，通过for循环遍历整个数组，令数组不断自增，最后再除以数组中数据的数量</p><h4 id="4-取最大值"><a href="#4-取最大值" class="headerlink" title="4.取最大值"></a>4.取最大值</h4><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/get_max_num.png?raw=true"></p><h2 id="七-字符串"><a href="#七-字符串" class="headerlink" title="七.字符串"></a>七.字符串</h2><p>C语言中字符串可以定义为:”c1,c2.c3…..cn \0”其中\0是结束符，算作一个字符</p><h3 id="1-转义字符"><a href="#1-转义字符" class="headerlink" title="1.转义字符"></a>1.转义字符</h3><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs11.png?raw=true"></p><p>字符串(“a”)和字符常量(‘a’)的区别</p><p>字符串是存储在静态区的，”a”对应的是字符串的首地址,所以可以赋值给字符指针</p><p>而字符常量’a’只是赋值给变量，不存储在静态区域，没有内存，不可赋值给字符指针</p><h3 id="2-宽字符串"><a href="#2-宽字符串" class="headerlink" title="2.宽字符串"></a>2.宽字符串</h3><p>wchat_t类型</p><pre><code class="highlight c"><span class="type">wchar_t</span> a = <span class="string">L&quot;Hello,世界&quot;</span>；</code></pre><p>宽字符串相比普通字符串，其中所有的字符都占两个字节，但是响应速度更快</p><h3 id="3-使用malloc函数动态分配内存调用字符串"><a href="#3-使用malloc函数动态分配内存调用字符串" class="headerlink" title="3.使用malloc函数动态分配内存调用字符串"></a>3.使用malloc函数动态分配内存调用字符串</h3><p>用例:</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs12.png?raw=true"></p><p>把字符串存放在堆上来调用字符串</p><p>这样，可以通过指针移动来遍历整个字符串，知道遇到字符’\0’</p><h3 id="4-字符串做函数参数"><a href="#4-字符串做函数参数" class="headerlink" title="4.字符串做函数参数"></a>4.字符串做函数参数</h3><pre><code class="highlight c"><span class="type">void</span> <span class="title function_">print_str</span><span class="params">(<span class="type">char</span> *str)</span>&#123;    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)&#123;        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*str);        <span class="comment">//定义一个函数，不断遍历指针*str的字符，直到遇到&#x27;\0&#x27;</span>        str++;    &#125;&#125;<span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;    <span class="type">char</span> *str = <span class="string">&quot;hello world&quot;</span>;       <span class="comment">//向指针中传递参数，用定义的函数print_str输出</span>    print_str(str);    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="5-字符串api"><a href="#5-字符串api" class="headerlink" title="5.字符串api"></a>5.字符串api</h3><p>有3套库函数，strxxx&#x2F;wcsxxx&#x2F;_tcsxxx，建议使用tchar的写法(兼容多字节字符集工程和UNICODE字符集工程):</p><pre><code class="highlight c"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span>TCHAR *tstr = _T(<span class="string">&quot;Hello world&quot;</span>);</code></pre><ul><li>strcpy 将字符串拷贝到另一个变量或数组</li></ul><pre><code class="highlight c"><span class="built_in">strcpy</span>(要拷贝到的变量或数组,原位置);<span class="built_in">strcpy</span>(buf1,s1);_tcscpy(buf2,s2);</code></pre><ul><li>strcmp比较两个字符串</li></ul><pre><code class="highlight c"><span class="built_in">strcmp</span>(s1,s2);<span class="built_in">strncmp</span>(s1,s2,<span class="number">5</span>);        <span class="comment">//用于比较字符串中前几个字符是否相等</span>stricmp(s1,s2);          <span class="comment">//忽略大小写</span>strnicmp(s1,s2,<span class="number">3</span>);       <span class="comment">//与strncmp相同，忽略大小写</span></code></pre><ul><li>strcat拼接两个字符串</li></ul><pre><code class="highlight c"><span class="type">char</span> path[<span class="number">260</span>] = <span class="string">&quot;c:\\doc\\test\\&quot;</span>;<span class="type">char</span> *filename = <span class="string">&quot;meow.txt&quot;</span>;<span class="built_in">strcat</span>(path,filename);<span class="built_in">printf</span>(<span class="string">&quot;path:%s\n&quot;</span>,path);</code></pre><ul><li>strchr(strrchr)查找</li></ul><pre><code class="highlight c"><span class="type">char</span> *p = <span class="built_in">strchr</span>(path,<span class="string">&#x27;x&#x27;</span>);</code></pre><p>用于从左到右查找字符串中的一个字符是否存在，若存在，则输出以后的所有内容(如果是strrchr则是从右往左)</p><p>同样的strstr可以查找字符串，用法类似</p><ul><li>strtok分割（两个参数，strtok(要分割的字符串,分割符)）</li></ul><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs13.png?raw=true"></p><ul><li>atoi(字符串转整型)&#x2F;atof(字符串转浮点)&#x2F;atol(字符串转长整型)&#x2F;atoll(字符串转long long)&#x2F;_ttol(针对TCHAR)</li></ul><h2 id="八-函数"><a href="#八-函数" class="headerlink" title="八.函数"></a>八.函数</h2><p>在C中，把为了实现某一特定的功能的所有语句归纳在一起，就形成了一个函数。一般来说，函数只实现单一功能</p><p>引用自己的函数:</p><p>1.创建一个.cpp源文件，将函数写进.cpp文件中，函数在写的时候需要一个返回值，ruturn函数计算的结果</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/func1.png?raw=true"></p><p>2.创建一个.h头文件,在头文件中写入引用的函数(#pragma once是用于同一个头文件被包含多次)</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/func2.png?raw=true"></p><p>同时，ifndef也可以保证头文件只被一次包含</p><pre><code class="highlight c"><span class="meta">#<span class="keyword">ifndef</span> _Exemple_</span><span class="meta">#<span class="keyword">define</span> _Exemple_</span>....(包含的函数)<span class="meta">#<span class="keyword">endif</span></span></code></pre><p>3.使用(#include “要包含的自己创建的头文件”)</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/func3.png?raw=true" alt="使用"></p><h3 id="1-命令行参数"><a href="#1-命令行参数" class="headerlink" title="1.命令行参数"></a>1.命令行参数</h3><pre><code class="highlight c"><span class="type">int</span> _tmain(<span class="type">int</span> argc,_TCHAR* argv[])&#123;    ...&#125;</code></pre><p>其中,argc为命令行参数的个数,argv[]存放命令行参数</p><h3 id="2-函数的注意事项-模块化-方便调试-维护"><a href="#2-函数的注意事项-模块化-方便调试-维护" class="headerlink" title="2.函数的注意事项(模块化,方便调试,维护)"></a>2.函数的注意事项(模块化,方便调试,维护)</h3><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs14.png?raw=true"></p><ul><li>变量初始化，在函数局部变量要保证初始化</li><li>严进宽出: 在一开始排除非法数据，后面轻松</li><li>assert：对参数进行断言</li><li>时间与空间复杂度: 内存少，使用快，尽量优化，不要分配内存(malloc)</li><li>边界考虑: 对条件充分考虑，避免特殊情况发生</li><li>功能测试: 在不同用例中测试函数的功能是否运行正常</li></ul><h3 id="3-库函数"><a href="#3-库函数" class="headerlink" title="3.库函数"></a>3.库函数</h3><p>库函数都有官方的说明文档，可以通过官方文档来进行传参，调试</p><h3 id="4-errno-t函数"><a href="#4-errno-t函数" class="headerlink" title="4.errno_t函数"></a>4.errno_t函数</h3><p>errno_t函数可以用来查看错误码(存放在头文件<strong>Windows.h</strong>中)，用例:</p><pre><code class="highlight c"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>...<span class="type">errno_t</span> err = GetLastError();<span class="built_in">printf</span>(<span class="string">&quot;err: %d&quot;</span>,err);</code></pre><p>例:传回来的错误码可以在工具Error Lookup(错误查找)中查看(visual stdudio):</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Error_Lookup.png?raw=true"></p><h3 id="5-面向过程和面向对象"><a href="#5-面向过程和面向对象" class="headerlink" title="5.面向过程和面向对象"></a>5.面向过程和面向对象</h3><p>C语言是面向过程的一门编程语言</p><p>两者的区别是:</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs15.png?raw=true"></p><p>面向对象,所有的动作都对应一个对象</p><p>面向过程,每个动作都是从一个动词开始的，每个动作对应一个函数</p><h3 id="6-函数的传参"><a href="#6-函数的传参" class="headerlink" title="6.函数的传参"></a>6.函数的传参</h3><p>3种方式</p><p>1.传值: 形参是对实参值的一个拷贝，形参和实参是不相关。无法通过改变形参来改变实参</p><p>2.传指针: 形参是对实参地址的一个拷贝，通过地址可以实现对实参的修改</p><p>3.传引用: 形参是对实参的一个引用（别名），形参就是实参本身，改变形参就是改变实参本身</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs16.png?raw=true"></p><p>函数用参数作为返回值</p><ul><li>变量既是输入，也是输出参数</li></ul><pre><code class="highlight c"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> *x,<span class="type">int</span> y)</span>;          <span class="comment">//*x = *x + y;</span></code></pre><p>数组做函数参数，防溢出：</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs17.png?raw=true"></p><h3 id="7-函数的调用约定"><a href="#7-函数的调用约定" class="headerlink" title="7.*函数的调用约定"></a>7.*函数的调用约定</h3><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/callingcvt1.png?raw=true"></p><p>默认调用约定:</p><pre><code class="highlight c"><span class="type">int</span> <span class="title function_">func</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</code></pre><p>cdecl调用约定:(参数入栈顺序：从右到左。调用者修改栈，所以可以支持变参函数，因为能恢复栈平衡)</p><pre><code class="highlight c">int__cdecl <span class="title function_">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;               <span class="comment">//先是y入栈，再是x</span></code></pre><p>stdcall调用约定:（从右往左压入栈。被调用函数自身修改栈）</p><pre><code class="highlight c">int__stdcall <span class="title function_">func</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</code></pre><p>fastcall调用约定:(函数的第一个和第二个通过ecx和edx传递，剩余参数从右到左入栈。被调用者修改栈)</p><pre><code class="highlight c">int__fastcall <span class="title function_">func</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span>;</code></pre><p> <strong>栈</strong>的增长方向和内存增长方向相反</p><p>先是参数入栈，然后是返回地址入栈（<strong>eip</strong>）(调用完当前函数后下一条要执行的指令)，接着是ebp寄存器入栈(debug版本)，最后是esp寄存器（占领寄存器），然后得到局部变量区的空间。<br>函数调用完之后，开始出栈，esp到达参数区域时，要使内存完全释放，需要+（对应参数的值）*4+4</p><p><u>每个参数在入栈时都会被提升至4个字节</u></p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs18.png?raw=true"></p><p><strong>x64平台统一使用fastcall约定</strong></p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs19.png?raw=true"></p><p>区别:</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs20.png?raw=true"></p><h3 id="8-inline（内联函数）"><a href="#8-inline（内联函数）" class="headerlink" title="8.inline（内联函数）"></a>8.inline（内联函数）</h3><p>优点:没有栈操作，运行效率高<br>缺点:代码会变大</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs21.png?raw=true"></p><h3 id="9-static关键字"><a href="#9-static关键字" class="headerlink" title="9.static关键字"></a>9.static关键字</h3><p>static(静态)，限制函数只在当前文件下使用，防止命名冲突</p><h3 id="10-函数设计的常见问题"><a href="#10-函数设计的常见问题" class="headerlink" title="10.函数设计的常见问题"></a>10.函数设计的常见问题</h3><h4 id="1-printf打印结果代替返回值"><a href="#1-printf打印结果代替返回值" class="headerlink" title="1.printf打印结果代替返回值"></a>1.printf打印结果代替返回值</h4><p>输出结果返回给调用者，printf没有任何意义，调用者是看不到的</p><h4 id="2-逻辑全部或者部分放在了main函数"><a href="#2-逻辑全部或者部分放在了main函数" class="headerlink" title="2.逻辑全部或者部分放在了main函数"></a>2.逻辑全部或者部分放在了main函数</h4><p>算法必须单独写成普通函数，然后在main函数里测试。main里不能有算法逻辑或者功能部分，main只负责数据测试</p><h4 id="3-调用了库函数"><a href="#3-调用了库函数" class="headerlink" title="3.调用了库函数"></a>3.调用了库函数</h4><h4 id="4-代码缺少封装"><a href="#4-代码缺少封装" class="headerlink" title="4.代码缺少封装"></a>4.代码缺少封装</h4><h4 id="5-函数内部内存分配"><a href="#5-函数内部内存分配" class="headerlink" title="5.函数内部内存分配"></a>5.函数内部内存分配</h4><h4 id="6-硬编码"><a href="#6-硬编码" class="headerlink" title="6.硬编码"></a>6.硬编码</h4><h4 id="7-指针移动"><a href="#7-指针移动" class="headerlink" title="7.指针移动"></a>7.指针移动</h4><p>一块N个字节的内存，它的首地址（头指针）为pstart，那么末地址为：</p><pre><code class="highlight c">pStart+N<span class="number">-1</span>;</code></pre><h2 id="九-指针"><a href="#九-指针" class="headerlink" title="九.指针"></a>九.指针</h2><p>指针就是一个变量(x86 占4个字节,x64占8个自己字节)，它与其他变量的不同就在于它的值是一个内存地址，指向内存的某一个地方，明确了该内存的宽度（通过指针类型确定）。指针含义分为3个方面：（变量&amp;&amp;地址&amp;&amp;内存宽度）</p><h3 id="解引用（dereference）运算符"><a href="#解引用（dereference）运算符" class="headerlink" title="*解引用（dereference）运算符"></a>*解引用（dereference）运算符</h3><p>通过指针（存放的内存地址），找到对应的内存和里面存放的数据类似于邮递员根据信封地址，找到地点</p><p>&amp;和*互为逆运算</p><p>*&amp;与&amp;*(&amp;:取变量的地址,*:取地址对应的内存)，如果为void类型，那么长度不确定,GCC中默认为1字节</p><pre><code class="highlight c"><span class="type">int</span> a = <span class="number">10</span>;*&amp;a == a;&amp;*a;   <span class="comment">//error</span><span class="type">int</span> *p = &amp;a;*p == a;*&amp;p == p;&amp;*p == p;</code></pre><h3 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h3><p>一级指针中存放的是普通变量的内存地址，二级指针中存放的是一级指针的地址</p><p>作用:传参是改变一级指针的值</p><p>传参：</p><pre><code class="highlight c"><span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> x)</span>;          <span class="comment">//传实参值，不能改变实参</span><span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> *x)</span>;         <span class="comment">//穿实参指针，修改实参</span><span class="type">int</span> <span class="title function_">func3</span><span class="params">(<span class="type">int</span> &amp;x)</span>;         <span class="comment">//传实参引用，修改实参</span><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> **x)</span>;        <span class="comment">//实参是指针，传指针的指针，修改指针</span><span class="type">int</span> <span class="title function_">func5</span><span class="params">(<span class="type">int</span> *&amp;x)</span>;        <span class="comment">//实参是指针，传指针的引用，修改指针</span></code></pre><h2 id="十-内存"><a href="#十-内存" class="headerlink" title="十.内存"></a>十.内存</h2><p>系统虚拟内存空间布局：</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs22.png?raw=true"></p><p>内存分类:</p><ul><li>堆heap</li><li>栈stack</li><li>静态区</li><li>代码区</li></ul><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs23.png?raw=true"></p><p>图为内存由上往下增长</p><h3 id="1-堆和栈的区别"><a href="#1-堆和栈的区别" class="headerlink" title="1.堆和栈的区别"></a>1.堆和栈的区别</h3><p>内存分配</p><ul><li>栈：由系统自动分配与回收,int b &#x3D; 0;增长由高到低</li><li>堆: malloc&#x2F;free,地址由低到高</li></ul><p>大小限制</p><ul><li>栈：应用层1M到10M，内核层: 12k到24k不等</li><li>堆：受限于计算机系统中有效的虚拟内存</li></ul><p>效率比较</p><ul><li>栈：由系统自动分配，速度较快。但是程序员无法控制</li><li>堆：速度比较慢，而且容易产生内存碎片</li></ul><p>存放内容：</p><ul><li>栈：栈是用来记录程序执行时函数调用过程中的活动记录（栈帧），参数，返回地址，ebp，局部变量等</li><li>堆：一般是在堆的头部用一个自己存放堆的大小，剩余部分存储的内容由程序员根据程序计算的需要决定</li></ul><h3 id="2-内存地址分类和寻址模式"><a href="#2-内存地址分类和寻址模式" class="headerlink" title="2.内存地址分类和寻址模式"></a>2.内存地址分类和寻址模式</h3><p>1.逻辑地址，线性地址，物理地址</p><ul><li><p>逻辑地址是编译器生成的，使用C语言指针时，指针的值就是逻辑地址。逻辑地址由段地址+段内偏移组成</p></li><li><p>线性地址是有分段机制将逻辑地址转化而来的。</p></li><li><p>物理地址是CPU在存取数据时最终在地址总线上发出的电平信号，靠改地址来访问对应数据</p></li></ul><p>2.内存的寻址模式</p><ul><li>扁平模型</li><li>分段模型</li><li>实模式</li><li>保护模式</li></ul><h3 id="3-内存分配"><a href="#3-内存分配" class="headerlink" title="3.内存分配"></a>3.内存分配</h3><p>malloc&#x2F;calloc&#x2F;relloc</p><pre><code class="highlight c"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_bytes)</span></code></pre><ul><li>num_bytes:分配的内存字节数</li><li>失败返回NULL，成功返回内存地址，内存中为垃圾值，需要清零，用free释放</li></ul><pre><code class="highlight c"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nelem,<span class="type">size_t</span> elsize)</span>;</code></pre><ul><li>nelem:元素个数</li><li>elsize:元素长度</li><li>分配的内存会被初始化为0，free释放</li></ul><pre><code class="highlight c"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *mem_address,<span class="type">unsigned</span> <span class="type">int</span> newsize)</span>;</code></pre><p>先判断当前指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_address返回，如果空间不够。先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem——address所致内存区域，同时返回新分配的内存区域的首地址，记得free释放</p><h3 id="4-内存泄漏"><a href="#4-内存泄漏" class="headerlink" title="4.内存泄漏"></a>4.内存泄漏</h3><p>动态分配的内存在程序结束后而已值未释放，就出现了内存泄漏。一般场合说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的，使用完必须释放的内存。应用程序一般使用malloc,new等函数从堆中分配到一块内存，使用完后，程序必须负责响应的调用free或菏泽delete释放该内存块，否则，这块内存就不能被再次使用，就说这块内存泄漏了（频繁的内存泄漏，将最终耗尽珍格格内存资源，让系统性能大幅下降）</p><h4 id="几种内存泄漏的情况："><a href="#几种内存泄漏的情况：" class="headerlink" title="几种内存泄漏的情况："></a>几种内存泄漏的情况：</h4><p>1.分配了内存没有释放</p><p>2.调用了不正确的系统api</p><p>3.打开了句柄但是未关闭</p><h4 id="预防内存泄漏"><a href="#预防内存泄漏" class="headerlink" title="预防内存泄漏"></a>预防内存泄漏</h4><p>1.malloc&#x2F;free 和 new&#x2F;delete要配对出现</p><p>2.分支退出别忘记释放已分配的内存,（goto）,例：</p><pre><code class="highlight c"><span class="type">char</span> *p1=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">64</span>);<span class="keyword">if</span>(p1 == <span class="literal">NULL</span>)&#123;    <span class="keyword">goto</span> err;&#125;<span class="type">char</span> *p2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">128</span>);<span class="keyword">if</span>(p2==<span class="literal">NULL</span>)&#123;    <span class="keyword">goto</span> err;&#125;err:<span class="keyword">if</span>(p1)&#123;        <span class="built_in">free</span>(p1);    &#125;<span class="comment">//用goto函数集中释放内存</span><span class="keyword">if</span>(p2)&#123;        <span class="built_in">free</span>(p2);    &#125;</code></pre><p>3.一般函数内部如果一定要分配内存，那么最好是在函数内释放内存，不要返回堆上的内存</p><p>4.复杂引用使用引用计数</p><p>5.C++中使用智能指针</p><h2 id="十一-结构体"><a href="#十一-结构体" class="headerlink" title="十一.结构体"></a>十一.结构体</h2><p>定义:struct（结构体），是由若干个“成员”组成的（每个成员可能是<strong>不同类型</strong>的数据），每一个成员可以是一个基本数据类型或者又是一个构造类型，结构体在底层编程中大量存在</p><p>基本的定义方法(例)：</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs24.png?raw=true"></p><p>访问结构体中的内容（使用指针需要使用箭头来访问结构体中的内容）：</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs25.png?raw=true"></p><h3 id="与-和-运算符"><a href="#与-和-运算符" class="headerlink" title="*与-&gt;和.运算符"></a>*与-&gt;和.运算符</h3><p>因为-&gt;与.运算符比*的优先级高，所以如果没有括号，先算-&gt;和.</p><pre><code class="highlight c"><span class="comment">//ps2是一个指针</span><span class="built_in">printf</span>(<span class="string">&quot;id:%s&quot;</span>,*ps2.id);     <span class="comment">//报错，认为id前面没有类型</span><span class="built_in">printf</span>(<span class="string">&quot;id:%s&quot;</span>,(*ps2).id);   <span class="comment">//成功，因为*ps2=s2,等价于s2.id</span><span class="built_in">printf</span>(<span class="string">&quot;id:%s&quot;</span>,ps2-&gt;id);     <span class="comment">//一般用法</span></code></pre><p>tip:如果结构体内有指针，需要让指针指向一个有效的内存</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs26.png?raw=true"></p><h3 id="2-浅拷贝和深拷贝"><a href="#2-浅拷贝和深拷贝" class="headerlink" title="2.浅拷贝和深拷贝"></a>2.浅拷贝和深拷贝</h3><p>浅拷贝只拷贝结构体的<strong>字段值</strong>，包括指针类型成员的<strong>地址</strong>。也就是说，浅拷贝只复制指针的值（即它所指向的内存地址），但不复制指针所指向的实际数据。</p><p>深拷贝不仅拷贝结构体的字段值，还<strong>拷贝指针所指向的数据</strong>。也就是说，深拷贝为指针指向的实际数据分配新的内存，并将数据拷贝到新内存中。</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs27.png?raw=true"></p><p>如果分配了内存，浅拷贝会导致被拷贝的变量释放内存后，接收拷贝的变量指向的值无效</p><p>浅拷贝:</p><pre><code class="highlight c">Person p2 = p1;  <span class="comment">// 浅拷贝，将person中p1的值复制给p2</span></code></pre><p>深拷贝:</p><pre><code class="highlight c">s1.a = <span class="number">10</span>;                            <span class="comment">//tip: s1和s2都为一个同一个结构体的变量</span>s1.p = <span class="number">10</span>;s1.p = (cahr*)<span class="built_in">malloc</span>(<span class="number">100</span>);s2.a = s1.a;s2.p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);            <span class="comment">//分配内存</span><span class="built_in">memcpy</span>(s2.p, s1.p, <span class="number">100</span>);              <span class="comment">//复制s1.p的内存到s2.p的内存中  </span><span class="built_in">free</span>(s1.p)                            <span class="comment">//内存释放后s2.p的值不会受到影响</span></code></pre><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs28.png?raw=true"></p><h3 id="3-结构体的应用"><a href="#3-结构体的应用" class="headerlink" title="3.结构体的应用"></a>3.结构体的应用</h3><p>结构体的遍历</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs29.png?raw=true"></p><p>输出结果:</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs30.png?raw=true"></p><p>基本类型大小:</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs31.png?raw=true"></p><p>自然对齐：</p><p>(1)数据成员对齐规则：</p><p>各成员变量存放的起始地址相对于结构的起始地址的偏移量:sizeof（基本类型）或其倍数</p><p>(2)整体的对齐规则:</p><p>结构的总大小也有个约束条件：最大sizeof（基本类型）的整数倍</p><p>好处：CPU在一个始终周期内存存取数据，效率高</p><pre><code class="highlight c"><span class="comment">//定义对齐</span><span class="meta">#<span class="keyword">pragma</span> pack(n)            <span class="comment">//定义对齐的个数</span></span>...                        <span class="comment">//定义结构体</span><span class="meta">#<span class="keyword">pragma</span> pack(pop)          <span class="comment">//恢复对齐状态</span></span></code></pre><p>栈空间的对齐：</p><p>栈形参对齐（x86中所有形参会提升到4个字节，x64会提升到8个字节）</p><h3 id="4-联合体"><a href="#4-联合体" class="headerlink" title="4.联合体"></a>4.联合体</h3><p>定义: 把几种不同类型的变量存放到同一段内存单元中。也就是使用<strong>覆盖技术</strong>，几个变量相互覆盖重叠，共同占用一段内存的结构体，被称为联合体</p><p>定义方式（与结构体类似）：</p><pre><code class="highlight c"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">foo</span>&#123;</span>    <span class="type">char</span> s[<span class="number">10</span>];    <span class="type">int</span> i;&#125;foo,*pfoo;foo a;                  <span class="comment">//定义a为foo类型</span></code></pre><p>例：</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs32.png?raw=true"></p><p>其中，因为联合体共同使用一段内存，所以a.i和a.s的地址相同。而最后sizeof的值是因为，联合体的大小为联合体成员中最大成员的字节大小，所以sizeof(a)的大小为20。a.i的值发生变化是因为hello world对应的是”dlrow olleh”的十六进制，转换成10进制的值</p><h4 id="结构体和联合体互相包含"><a href="#结构体和联合体互相包含" class="headerlink" title="结构体和联合体互相包含"></a>结构体和联合体互相包含</h4><p>基本定义和访问方法（联合体包含结构体）：</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs33.png?raw=true"></p><p>结构体包含联合体（相似访问方法）</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs34.png?raw=true"></p><p>利用联合体来检测系统是高位优先还是低位优先：</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/Cs35.png?raw=true"></p><p>原理是，联合体中所有成员共享同一块内存区域，而x被设定为1,16进制则是：0x000000001。在高位优先系统中，c的整数字节的最高有效字节为0，故返回false，而低位优先系统中返回的则是1，即true</p><h2 id="十二-运算符"><a href="#十二-运算符" class="headerlink" title="十二.运算符"></a>十二.运算符</h2><h3 id="1-枚举类型"><a href="#1-枚举类型" class="headerlink" title="1.枚举类型"></a>1.枚举类型</h3><p>定义：当一个变量的值被限于列出来的值的范围内，那么这个变量就可以被定义为一个枚举类型的变量</p><p>枚举实际上是整数类型的一个集合。C语言给每个枚举的名称自动分配一个整数值，从0开始。如果不显式指定其他值，它们会依次递增。</p><p>基本定义方法：</p><pre><code class="highlight c"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _枚举名&#123;</span>    值<span class="number">1</span>,                 <span class="comment">//从0开始</span>    值<span class="number">2</span>,<span class="comment">//1</span>    ...    值n, <span class="comment">//n-1</span>&#125;枚举名,*P枚举名;枚举名 变量名;              <span class="comment">//用法与结构体联合体类似</span></code></pre><p>枚举类型里面的值为常量，无法被修改</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/Cs36.png?raw=true"></p><p>分别sizeof枚举名，枚举成员，枚举变量得到的结果都为4</p><p>因为枚举的底层是int类型，int类型在x86和x64上均占用4个字节</p><h3 id="2-位运算"><a href="#2-位运算" class="headerlink" title="2.位运算"></a>2.位运算</h3><p>byte:比特      bit:位</p><p>定义：程序中的数据再内存中，都是以二进制的形式存在的，所以，内存中的数据一般都是0和1组成的序列。所谓位运算就是直接对整数在内存中的二进制位进行位运算操作（按位操作）</p><p>位运算分为：与(and，&amp;),或(or,|),取反(not,~),异或(xor,^),左移(shl,&lt;&lt;),右移(shr&#x2F;sar,&gt;&gt;)等几种运算</p><p>运算符:&amp;，|，~，^，&lt;&lt;，&gt;&gt;</p><h4 id="1-与运算（-）"><a href="#1-与运算（-）" class="headerlink" title="1.与运算（&amp;）"></a>1.与运算（&amp;）</h4><p>两个数进行位运算，只有当两个数对应的为都为1，该位运算结果为1，否则运算结果为0</p><p>例：1&amp;1 &#x3D; 1 ， 1&amp;0 &#x3D; 0，0&amp;0 &#x3D; 0</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/Cs37.png?raw=true"></p><p>如果想要取后三位：x &amp; 0x7即可，因为0x7 &#x3D; 00000111</p><h4 id="2-或运算（-）"><a href="#2-或运算（-）" class="headerlink" title="2.或运算（|）"></a>2.或运算（|）</h4><p>和与运算相反，只有当两个数对应的都为0，该位运算结果才为0，否则都为1</p><p>例：1|1 &#x3D; 1 , 1|0&#x3D;1,  0|0 &#x3D; 0</p><h4 id="3-异或（-）"><a href="#3-异或（-）" class="headerlink" title="3.异或（^）"></a>3.异或（^）</h4><p>定义：2个数进行异或运算时，就是将这2个数的二进制进行异或操作，只要两个数对应的位相同，该位运算结果为0，否则运算结果为1</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/Cs38.png?raw=true"></p><p>性质：任何一个数和0异或就是它本身，与自己异或等于0</p><ul><li>a^0&#x3D;a</li><li>a^a&#x3D;0</li></ul><pre><code class="highlight c">a=a^b;b=a^b;          <span class="comment">//两数交换</span>a=a^b;</code></pre><h4 id="4-取反（-）"><a href="#4-取反（-）" class="headerlink" title="4.取反（~）"></a>4.取反（~）</h4><p>顾名思义，就是将二进制的每一位取反</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/Cs39.png?raw=true"></p><h4 id="5-移位（）"><a href="#5-移位（）" class="headerlink" title="5.移位（&lt;&lt;,&gt;&gt;）"></a>5.移位（&lt;&lt;,&gt;&gt;）</h4><h5 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h5><ul><li>将一个数左移N位，那么左边会去掉N位，右边会空出N位，空出的填0</li><li>将一个数左移N位相当于将这个数乘以2^N</li></ul><h5 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h5><ul><li>将一个数右移N位，右边会去掉N位，左边会空出N位 在逻辑右移中，左边空N位用0填充，在算数右移中，左边空位用符号位来填充</li></ul><p>为什么用移位运算符？效率高</p><h4 id="6-移位运算符的运用"><a href="#6-移位运算符的运用" class="headerlink" title="6.移位运算符的运用"></a>6.移位运算符的运用</h4><h5 id="1-将第N位置置0或者置1"><a href="#1-将第N位置置0或者置1" class="headerlink" title="(1)将第N位置置0或者置1"></a>(1)将第N位置置0或者置1</h5><pre><code class="highlight c"><span class="meta">#<span class="keyword">define</span> SETFALG(a,n) ((a)|=(1&lt;&lt;(n)))      <span class="comment">//将1左移n位和a的值进行或运算，将第n位置1</span></span><span class="meta">#<span class="keyword">define</span> CLEARFLAG(a,n) ((a)&amp;= ~(1&lt;&lt;(n)))  <span class="comment">//将第n位置0</span></span><span class="meta">#<span class="keyword">define</span> FLAGON(a,n) ((a) &amp; (1&lt;&lt;(n)))      <span class="comment">//判断第n位是否为1，如果要判断是否为0，取反即可</span></span></code></pre><h5 id="2-对称加密-xor"><a href="#2-对称加密-xor" class="headerlink" title="(2)对称加密(xor)"></a>(2)对称加密(xor)</h5><p>异或性质 a^0 &#x3D;&#x3D; a , a^a &#x3D;&#x3D; 0</p><p>A为明文，B为密文</p><p>加密：B&#x3D;A^key</p><p>解密：A &#x3D; B^key</p><pre><code class="highlight c"><span class="type">void</span> <span class="title function_">xor1</span><span class="params">(<span class="type">char</span> *data,<span class="type">int</span> datalen,<span class="type">char</span> *key,<span class="type">int</span> keylen)</span> &#123;<span class="type">int</span> i;<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; datalen; i++) &#123;data[i] = (<span class="type">char</span>)(data[i] ^ key[i % keylen]);&#125;&#125;                                  <span class="comment">//异或加密</span></code></pre><h2 id="十三-宏"><a href="#十三-宏" class="headerlink" title="十三.宏"></a>十三.宏</h2><h3 id="1-宏定义"><a href="#1-宏定义" class="headerlink" title="1.宏定义"></a>1.宏定义</h3><p>宏定义是只用一个标志符代表一个字符串，该标志符就称为宏名</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/Cs40.png?raw=true"></p><p>宏定义的优缺点：</p><ul><li>有意义</li><li>减少修改</li><li>无类型检查</li><li>无法调试</li></ul><p>两种基本用法</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/Cs41.png?raw=true"></p><p><strong>优缺点比较：</strong></p><p>1.宏的效率要高（inline），没有了函数调用过程中的进栈传参拷贝和出栈栈平衡</p><p>2.宏无法调试</p><p>3.宏无法做到类型检查</p><p>4.传参计算不同，红石简单的替换；函数先计算，再传参</p><p><strong>宏的多行定义</strong></p><pre><code class="highlight c"><span class="meta">#<span class="keyword">define</span> SWAP(a,b) \</span><span class="meta">int temp;\</span><span class="meta">temp = a;\              <span class="comment">//使用两个反斜线将多行连起来</span></span>a=b;\b=temp;</code></pre><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/Cs42.png?raw=true"></p><p>可以使用大括号将所有语句连接起来</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/Cs43.png?raw=true"></p><h3 id="2-条件编译"><a href="#2-条件编译" class="headerlink" title="2.条件编译"></a>2.条件编译</h3><p>判断宏是否被定义</p><pre><code class="highlight c"><span class="meta">#<span class="keyword">ifndef</span> WINVER<span class="comment">//判断WINVER是否定义，if no defined</span></span>...;<span class="meta">#<span class="keyword">else</span></span>    ...;<span class="meta">#<span class="keyword">endif</span>                     <span class="comment">//结束</span></span></code></pre><p>加常量表达式</p><pre><code class="highlight c"><span class="meta">#<span class="keyword">if</span> 0</span>...;               <span class="comment">//1即执行，0则不执行，可以用0来注释掉一段代码</span><span class="meta">#<span class="keyword">endif</span></span></code></pre><p>elif语句(例)</p><pre><code class="highlight c"><span class="meta">#<span class="keyword">if</span> defined(X64)            <span class="comment">//if deined 顾名思义</span></span><span class="built_in">printf</span>(<span class="string">&quot;x64 platform specific\n&quot;</span>);<span class="meta">#<span class="keyword">elif</span> defined(x86)</span><span class="built_in">printf</span>(<span class="string">&quot;x86 platform specific\n&quot;</span>);<span class="meta">#<span class="keyword">else</span></span><span class="built_in">printf</span>(<span class="string">&quot;common code\n&quot;</span>);<span class="meta">#<span class="keyword">endif</span>                                        <span class="comment">//结束</span></span></code></pre><h2 id="十四-递归"><a href="#十四-递归" class="headerlink" title="十四.递归"></a>十四.递归</h2><p>概念：递归是指某个函数直接或者间接的调用自身</p><p>递归首先需要有一个或多个<strong>递归出口</strong>，即递归终止的条件，也就是<strong>最小子问题</strong>的求解，可以允许多个出口。</p><p>递归还需要有一个<strong>递归式</strong>，这个递归式规定如何将<strong>原问题划分成子问题</strong></p><p>以斐波那契数列为例</p><pre><code class="highlight c"><span class="type">int</span> <span class="title function_">feibo</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> &#123;<span class="keyword">if</span> (n == <span class="number">1</span>|n == <span class="number">2</span>) &#123;<span class="keyword">return</span> <span class="number">1</span>;                               <span class="comment">//出口</span>&#125;<span class="keyword">else</span> &#123;<span class="keyword">return</span> feibo(n - <span class="number">1</span>) + feibo(n - <span class="number">2</span>);<span class="comment">//不断引用本身从第一位开始加</span>&#125;&#125;</code></pre><p>优缺点：</p><ul><li>简单实现</li><li>效率低</li><li>容易栈溢出</li><li>内核不能使用递归</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="1-反向输出"><a href="#1-反向输出" class="headerlink" title="1.反向输出"></a>1.反向输出</h4><pre><code class="highlight c"><span class="type">static</span> <span class="type">void</span> <span class="title function_">reverse_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> &#123;<span class="keyword">if</span> (s == <span class="literal">NULL</span> || *s == <span class="string">&#x27;\0&#x27;</span>) &#123;<span class="keyword">return</span>;&#125;reverse_printf(s + <span class="number">1</span>);<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *s);&#125;</code></pre><h2 id="十五-文件"><a href="#十五-文件" class="headerlink" title="十五.文件"></a>十五.文件</h2><p><strong>文件分类：</strong></p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/Cs44.png?raw=true"></p><p><strong>常见的文件系统：</strong></p><p>Windows： FAT , NTFS</p><p>Linux：Ext2-4</p><p>Solaris：ZFS</p><p>VFS:</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/VFS.png?raw=true"></p><p>ZFS：</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/ZFS.png?raw=true"></p><h3 id="1-文本文件与二进制文件"><a href="#1-文本文件与二进制文件" class="headerlink" title="1.文本文件与二进制文件"></a>1.文本文件与二进制文件</h3><p>纯文本文件： .c文件，.txt文件，.html文件等</p><p>二进制文件： .exe文件，.dll文件，.jpg文件，.rmvb文件，.doc文件，.ppt文件等</p><h3 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2.文件操作"></a>2.文件操作</h3><p>1.文件创建（打开）</p><pre><code class="highlight c">fopen(<span class="string">&quot;C:\\newFile\\1.txt&quot;</span>,<span class="string">&quot;w,ccs=UTF-8&quot;</span>);   <span class="comment">//默认编码模式为ANSI</span></code></pre><p>参数如图：</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/Cs45.png?raw=true"></p><p>创建文件夹</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/Cs46.png?raw=true"></p><pre><code class="highlight c"><span class="type">int</span> <span class="title function_">create_dir</span><span class="params">()</span>&#123;                              <span class="comment">//定义一个函数</span>    <span class="type">char</span> *dirpath = <span class="string">&quot;d:\\test\\meow\\&quot;</span>        <span class="comment">//记录文件夹地址与名称</span>    <span class="type">int</span> res = _mkdir(dirpath);    <span class="keyword">return</span> res;&#125;</code></pre><pre><code class="highlight c"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;    res = create_dir();    <span class="keyword">if</span>(res == <span class="number">0</span>)&#123;        <span class="built_in">printf</span>(<span class="string">&quot;dir created!\n&quot;</span>);          <span class="comment">//文件夹创建成功</span>    &#125;    <span class="keyword">else</span>&#123;        <span class="built_in">printf</span>(<span class="string">&quot;dir create filed\n&quot;</span>);       <span class="comment">//创建失败</span>    &#125;&#125;</code></pre><p>tip：不能连续创建，只能一层一层创建</p><h3 id="3-读写"><a href="#3-读写" class="headerlink" title="3.读写"></a>3.读写</h3><p>fwrite写</p><pre><code class="highlight c">fwrite(buffer,size,ntime,fp);    <span class="comment">//size+1是加上\0字符，ntime是重复次数，fp为fopen指针</span><span class="comment">//用法,以下为示例</span>fwrite(<span class="string">&quot;hello&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;hello&quot;</span>)+<span class="number">1</span>,<span class="number">1</span>,fp);fclose(fp);</code></pre><p>fread读</p><pre><code class="highlight c">fread(buffer,suze,ntime,fp);      <span class="comment">//返回值表示读取份数</span><span class="comment">//用法，以下为示例</span><span class="type">char</span> buff[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;fread(buff,<span class="built_in">strlen</span>(<span class="string">&quot;hello&quot;</span>)+<span class="number">1</span>,<span class="number">1</span>,fp);</code></pre><p>读写流程</p><pre><code class="highlight c"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;      <span class="comment">// 定义文件指针  </span>    FILE *file;      <span class="comment">// 写入文件  </span>    file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>); <span class="comment">// 以写入方式打开文件  </span>    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;          perror(<span class="string">&quot;无法打开文件&quot;</span>);          <span class="keyword">return</span> EXIT_FAILURE;      &#125;      <span class="built_in">fprintf</span>(file, <span class="string">&quot;hello&quot;</span>); <span class="comment">// 写入字符串 &quot;hello&quot;  </span>    fclose(file); <span class="comment">// 关闭文件  </span>    <span class="comment">// 读取文件  </span>    file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="comment">// 以读取方式打开文件  </span>    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;          perror(<span class="string">&quot;无法打开文件&quot;</span>);          <span class="keyword">return</span> EXIT_FAILURE;      &#125;      <span class="type">char</span> buffer[<span class="number">100</span>]; <span class="comment">// 定义一个缓冲区来存储读取内容  </span>    <span class="built_in">fscanf</span>(file, <span class="string">&quot;%s&quot;</span>, buffer); <span class="comment">// 从文件中读取内容  </span>    <span class="built_in">printf</span>(<span class="string">&quot;读取内容: %s\n&quot;</span>, buffer); <span class="comment">// 打印读取的内容  </span>    fclose(file); <span class="comment">// 关闭文件  </span>    <span class="keyword">return</span> EXIT_SUCCESS;  &#125;</code></pre><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/Cs47.png?raw=true"></p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img1/Cs48.png?raw=true"></p>]]></content>
      
      
      <categories>
          
          <category> 周报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一周学习笔记</title>
      <link href="/2024/09/29/%E7%AC%AC%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/09/29/%E7%AC%AC%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><em><strong>实验室第一周学习内容：</strong></em></p><h1 id="1-搭建个人博客"><a href="#1-搭建个人博客" class="headerlink" title="1.搭建个人博客"></a>1.<strong>搭建个人博客</strong></h1><p>采用了hexo框架，windows安装git后使用git依次输入</p><pre><code class="highlight git">npm install -g hexo-cli     #全局安装hexohexo init                   #初始化博客npm install                 #安装hexo依赖包</code></pre><p>选定文件夹后git clone拉取hexo仓库后本地输入</p><pre><code class="highlight hexo">hexo s</code></pre><p>本地博客就在localhost上运行了，浏览器输入<a href="http://localhost:4000即可访问">http://localhost:4000即可访问</a></p><p>本地博客搭建完毕后，需要在公网上可以访问展示，使用github仓库为媒介，搭建博客</p><p>第一步是设置ssh密钥，在git上生成rsa密钥，输入</p><pre><code class="highlight git">ssh-keygen -t rsa -C &quot;xxxx@qq.com&quot;       #生成密钥，xxx填邮箱地址</code></pre><p>复制密钥后在github上创建两个ssh密钥连接</p><p>一个是sighin一个是auth</p><p>验证可以和github仓库连接后，输入</p><pre><code class="highlight plaintext">hexo g                          #生成html网页hexo d                          #deploy部署到github仓库</code></pre><p>随后访问<a href="https://sudg01.github.io/">https://sudg01.github.io/</a> 即可连接到博客网页</p><p>正好手头上有空闲的域名，使用域名CNAME解析到github仓库博客网页，再在github仓库界面设置好解析的域名，即可正常使用域名访问 <a href="https://sudg01.github.io/">blog.5x1ng.cn</a></p><h1 id="2-linux的指令学习—在RUNOOB-COM上学习"><a href="#2-linux的指令学习—在RUNOOB-COM上学习" class="headerlink" title="2.linux的指令学习—在RUNOOB.COM上学习"></a><strong>2.linux的指令学习—在RUNOOB.COM上学习</strong></h1><p>由于本机在招新赛时安装了Ubuntu20.04系统，于是直接使用Ubuntu系统进行linux的学习</p><p>Linux系统目录结构</p><p>1.ls 命令</p><pre><code class="highlight linux">ls</code></pre><h2 id="系统根目录下的目录解释"><a href="#系统根目录下的目录解释" class="headerlink" title="系统根目录下的目录解释"></a><strong>系统根目录下的目录解释</strong></h2><p>&#x2F;bin         存放命令                                                                                  &#x2F;media            识别的设备</p><p>&#x2F;boot      存放linux核心文件          &#x2F;mnt                临时文件挂载目录</p><p>&#x2F;dev        即divice，设备文件&#x2F;opt                 额外软件安装目录</p><p>&#x2F;etc         放置所有系统管理所需文件   &#x2F;proc               该目录在系统内存里，而不是在</p><p>​  硬盘里</p><p>&#x2F;home    用户目录                                                  &#x2F;root               超级权限者目录</p><p>&#x2F;lib          库文件      &#x2F;sbin               超级权限者的系统目录</p><p>&#x2F;srv         服务启动后要获取的数据                                                       &#x2F;sys                 系统文件</p><p>&#x2F;tmp       临时文件                                                                                  &#x2F;usr                 类似windows的program files文 件夹</p><p>&#x2F;usr&#x2F;bin   系统用户使用的应用程序     &#x2F;usr&#x2F;sbin        超级用户的程序</p><p>&#x2F;usr&#x2F;src    内核源代码默认目录                                                            &#x2F;var                 经常被修改的目录和各种日志文 件</p><p>&#x2F;run           储蓄启动以来所有的临时文件，系统重启后会清空</p><p>在linux中  <u>.&#x2F;代表当前目录</u>，<u>..&#x2F;代表上级目录</u></p><h2 id="linux文件基本属性"><a href="#linux文件基本属性" class="headerlink" title="linux文件基本属性"></a><strong>linux文件基本属性</strong></h2><p>可以用ll 或者ls -l来查看文件的属性以及所属的用户和组</p><p>有两个命令可以修改权限，分别为<u>chown</u>和<u>chmod</u>和<u>chgrp</u>命令</p><pre><code class="highlight linux">llls -l                       #查看文件权限</code></pre><p>chown：更改文件所有者<br>chgrp ：更改文件属组</p><p>chmod：更改文件9个属性</p><p>语法</p><pre><code class="highlight linux">chgrp [-R] 属组名 文件名chown [-R] 所有者 文件名chown [-R] 所有者:属组名 文件名</code></pre><p>r:4（读）                  w:2（写）                     x:1（执行）</p><p>owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</p><p>group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</p><p>others &#x3D; 0 + 0 + 0 &#x3D; 0</p><p>所以，chmod语法应该是</p><pre><code class="highlight linux">chmod [-R] xyz 文件或目录chmod 777 number</code></pre><p><img src="https://github.com/SUDG01/tuchuang/blob/main/learnlinux.png?raw=true"></p><h2 id="处理目录的常用指令"><a href="#处理目录的常用指令" class="headerlink" title="处理目录的常用指令"></a><strong>处理目录的常用指令</strong></h2><pre><code class="highlight plaintext">ls        #列出目录cd        #切换目录pwd       #显示目前目录mkdir     #创建一个新的目录rmdir     #删除一个空的目录cp        #复制文件或目录rm        #删除文件或目录，删除文件目录需要加-rmv        #移动文件或目录或修改名称</code></pre><h2 id="用户和用户组管理"><a href="#用户和用户组管理" class="headerlink" title="用户和用户组管理"></a><strong>用户和用户组管理</strong></h2><p>新建账号</p><pre><code class="highlight plaintext">useradd [选项] 用户名</code></pre><p>-c  comment</p><p>-d  目录</p><p>-g  用户组</p><p>-G  用户组 用户组</p><p>-s  Shell文件</p><p>-u  用户号</p><p>删除账号</p><pre><code class="highlight plaintext">userdel -r 用户名             #删除用户并删除主目录</code></pre><p>修改账号</p><pre><code class="highlight plaintext">usermod 选项 用户名</code></pre><p>切换账号</p><pre><code class="highlight plaintext">su 用户su                        #均需要管理员权限，单个su为切换为root账户</code></pre><p>用户名口令的管理</p><pre><code class="highlight plaintext">passwd 选项 用户名passwd                             #如果已经为该用户，直接输入即可进入修改流程</code></pre><p>增加用户组以及删除用户组和用户组属性的修改</p><pre><code class="highlight plaintext">groupadd 选项 用户组groupdel 用户组groupmod 选项 用户组</code></pre><p>-g GID 制定新的组标识号</p><p>-o -g 新用户可以与系统已有用户组的GID相同</p><p>-n 新用户组</p><h2 id="VI-VIM"><a href="#VI-VIM" class="headerlink" title="VI&#x2F;VIM"></a><strong>VI&#x2F;VIM</strong></h2><p><img src="https://github.com/SUDG01/tuchuang/blob/main/vim.png?raw=true" alt="vim"></p><pre><code class="highlight plaintext">i               #切换到输入模式，在光标当前位置开始输入文本x               #删除当前光标所在处的字符:               #切换到底线命令模式，以在最底一行输入命令a               #进入插入模式，在光标下一个位置开始输入文本o：             #在当前行的下方插入一个新行，并进入插入模式O               #在当前行的上方插入一个新行，并进入插入模式dd              #剪切当前行yy              #复制当前行p               #粘贴剪贴板内容到光标下方P               #粘贴剪贴板内容到光标上方u               #撤销上一次操作Ctrl + r        #重做上一次撤销的操作:w              #保存文件:q              #退出 Vim 编辑器:q!             #强制退出Vim 编辑器，不保存修</code></pre><p><strong>替换文本</strong></p><pre><code class="highlight plaintext">:s/旧字符串/新字符串                    #替换首个字符串:s/旧字符串/新字符串/g                  #替换光标所在行所有字符串:%s/旧/新/g                           #全文替换</code></pre><p><strong>查找文本</strong></p><p>处于交互模式，按下&#x2F;键，进入查找模式，输入字符串即可</p><p>n键：跳转到下一个匹配项</p><p>N键：跳转到上一个匹配项</p><p>tip:在vim中，撤销操作在命令模式下按<strong>u</strong>即可，取消撤销则为<strong>ctrl+r</strong></p><h2 id="yum和apt"><a href="#yum和apt" class="headerlink" title="yum和apt"></a><strong>yum和apt</strong></h2><p>由于yum指令是在CentOS&#x2F;redshell等系统上默认使用的，而Ubuntu是默认使用apt指令，安装yum库报错，且yum和apt的用法极为相似，所以我重点先学习apt</p><p>通常安装软件包更多还是使用apt-get，apt-get属于apt，属于更底层的工具，可以更好地控制包管理过程</p><p>使用apt指令的时候需要管理员权限，所以一般会在指令前加sudo指令，以超级用户权限进行操作</p><p>安装包</p><pre><code class="highlight plaintext">sudo apt install  包名sudo apt-get install  包名         #均为安装包</code></pre><p>检测是否存在并升级</p><pre><code class="highlight plaintext">sudo apt install 包名 --no-upgrade</code></pre><p>只升级，如果不存在就不升级</p><pre><code class="highlight plaintext">sudo apt install 包名 --only-upgrade</code></pre><p>移除包</p><pre><code class="highlight plaintext">sudo apt remove 包名</code></pre><p><strong>如何找出相关文件</strong></p><pre><code class="highlight plaintext">whereis [名称]</code></pre><p><img src="https://github.com/SUDG01/tuchuang/blob/main/626a4528-0ced-4123-8441-5c6488f24ead.png?raw=true"></p><p>即可找出所有相关的文件或文件夹</p><p><strong>下载文件</strong></p><pre><code class="highlight plaintext">wget 文件地址</code></pre><p><strong>打开文件（5个命令）</strong></p><p>1.cat命令</p><pre><code class="highlight plaintext">cat [文件或文件路径]</code></pre><p>2.more命令</p><pre><code class="highlight plaintext">more [文件或文件路径]                   #不展示全部，翻页使用，文本内容较多时可以使用</code></pre><p>如果想提前终止查看，按q即可终止查看</p><p>3.less命令</p><pre><code class="highlight plaintext">less [文件或文件路径]                    #与more类似，可以操作上下翻页，按q退出</code></pre><p>u:向上</p><p>j:向下</p><p>g:跳到第一行</p><p>G:跳到最后一行</p><p>4，head命令</p><pre><code class="highlight plaintext">head [参数] [文件或文件路径]               #查看文件的开头部分，默认看前面十行</code></pre><p>-n 指定看多少行的内容</p><p>-c 指定看多少个字节的内容</p><p>5.tail命令</p><pre><code class="highlight plaintext">tail [参数] [文件或文件路径]                 #查看文件的末尾部分，和head命令类似</code></pre><p><strong>查找文件</strong></p><p>find 命令</p><pre><code class="highlight plaintext">find [路径] [参数] [要查找的内容]</code></pre><p>-name 按名字查找</p><p>-size 按文件大小查找</p><p>示例:</p><pre><code class="highlight plaintext">find / -name &quot;text*&quot;                       #查找以text开头的文件，*是通配符,/是从根目录下查找find / -size +10M                          #查找大于10MB的文件</code></pre><p>在-size选项中，+代表大于，-代表小于</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/find.png?raw=true"></p><p>如图，输入find &#x2F; -name “text*”，即把所有以text为开头的文件查找出来</p><hr><p>还有一些小tip：</p><p>ctrl+c可以关闭不需要的实例</p><p>Tab键可以补齐指令</p><p>Ctrl+L  清屏</p><hr><p>第一周的学习非常充实</p><p>学习了github的基本使用以及博客和github的联系使用</p><p>还有linux的一些基本使用方式</p><p>内容非常多，还需要多巩固复习！！！</p>]]></content>
      
      
      <categories>
          
          <category> 周报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到SU小喵の小站</title>
      <link href="/2024/09/29/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0SU%E5%B0%8F%E5%96%B5%E3%81%AE%E5%B0%8F%E7%AB%99/"/>
      <url>/2024/09/29/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0SU%E5%B0%8F%E5%96%B5%E3%81%AE%E5%B0%8F%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p>Hallo，大家好！！</p><p>这里是SUX1NG，是一只小狐喵</p><p>随着时间的推移，小喵也是来到了大学，见识到了许多新的事物，也向着更发高难度的学业开始了自己的旅程 为此，小喵建设了一个属于自己的blog，以此来记录小喵在大学四年的学习生活，并希望能够记录到许多美好的事物&#x3D; v &#x3D; </p><p>emmmmmmmmmm</p><p>最后 </p><p>欢迎你来访问我的小网站！！！！！ </p><p>xwx</p>]]></content>
      
      
      <categories>
          
          <category> G3t5tart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> firstblog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
