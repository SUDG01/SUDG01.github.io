<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>大一上半学期疑难点</title>
      <link href="/2024/10/13/%E5%A4%A7%E4%B8%80%E4%B8%8A%E5%8D%8A%E5%AD%A6%E6%9C%9F%E7%96%91%E9%9A%BE%E7%82%B9/"/>
      <url>/2024/10/13/%E5%A4%A7%E4%B8%80%E4%B8%8A%E5%8D%8A%E5%AD%A6%E6%9C%9F%E7%96%91%E9%9A%BE%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="学习中遇到的困难"><a href="#学习中遇到的困难" class="headerlink" title="学习中遇到的困难"></a>学习中遇到的困难</h1><h2 id="1-在学习C中遇到的二维数组报错"><a href="#1-在学习C中遇到的二维数组报错" class="headerlink" title="1.在学习C中遇到的二维数组报错"></a>1.在学习C中遇到的二维数组报错</h2><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/char_arr_err.png?raw=true"></p><p>写的和用例上的相同，但是我的会出现报错</p><p>根据报错提示，尝试在char 前面加入const关键字</p><pre><code class="highlight c"><span class="type">const</span> <span class="type">char</span> name[<span class="number">3</span>][<span class="number">2</span>] = &#123;<span class="string">&quot;数学&quot;</span>,<span class="string">&quot;语文&quot;</span>,<span class="string">&quot;英语&quot;</span>&#125;;</code></pre><p>仍然报错</p><p>仔细思考了一下，提示中显示const char[7]和char[2],有理由怀疑列数不够，将2改成7之后，编译成功</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/char_arr_solve1.png?raw=true"></p>]]></content>
      
      
      <categories>
          
          <category> solved </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习</title>
      <link href="/2024/10/07/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/10/07/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="学习C语言"><a href="#学习C语言" class="headerlink" title="学习C语言"></a>学习C语言</h1><h2 id="一-PE格式"><a href="#一-PE格式" class="headerlink" title="一.PE格式"></a>一.PE格式</h2><h3 id="1-PE文件"><a href="#1-PE文件" class="headerlink" title="1.PE文件"></a>1.PE文件</h3><p>在win下：.exe .dll .sys</p><p>在linux下： elf</p><p>此类文件都属于PE结构的文件类型。</p><h3 id="2-PE文件的构成"><a href="#2-PE文件的构成" class="headerlink" title="2.PE文件的构成"></a>2.PE文件的构成</h3><p>由DOS部首，PE文件头，块表（section table）,块（section）以及调试信息组成</p><h4 id="DOS部首"><a href="#DOS部首" class="headerlink" title="DOS部首"></a>DOS部首</h4><p>最开始的部分是DOS部首，由DOS的MZ文件标志和DOS stub组成</p><p>（MZ）开头: e_magic ，为固定的值 “0x5a4d”</p><p>DOS Stub即为一句话”This program Cannot be run in DOS mode”</p><h4 id="PE文件头"><a href="#PE文件头" class="headerlink" title="PE文件头"></a>PE文件头</h4><p>最开始的部分是以’PE\0\0’:”0x50 0x45 00 00”开始的，由DOS部首中，结构成员e_lfanew(0x3c)指向</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs1.png?raw=true"></p><p>在PE文件头中，IMAGE_OPTIONAL_HEADER32和IMAGE_FILE_HEADER都定义了很多PE的数据</p><p>特别在IMAGE_OPTIONAL_HEADER32中，包含了数据结构表</p><p>数据结构表有导出表和导入表</p><p>导入表为引用的函数，导出表则为程序本身定义的函数</p><h4 id="块表"><a href="#块表" class="headerlink" title="块表"></a>块表</h4><p>块表指向块</p><h4 id="块"><a href="#块" class="headerlink" title="块"></a>块</h4><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs2.png?raw=true"></p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs3.png?raw=true"></p><p>RVA(相对虚拟地址)&#x3D; VA(虚拟地址) - ImageBase(起始地址)</p><p>VOFFSET &#x3D; 每个节的虚拟地址 - 起始地址</p><p>ROFFSET &#x3D; 每个节的虚拟地址 - 每个文件的首地址</p><h2 id="二-进制转换"><a href="#二-进制转换" class="headerlink" title="二.进制转换"></a>二.进制转换</h2><h3 id="1-表现形式"><a href="#1-表现形式" class="headerlink" title="1.表现形式"></a>1.表现形式</h3><p>在C语言中：16进制为0x开头，如（0x71ef）,x可以为大小写</p><p>在汇编语言中：</p><p>16进制为H结尾，如：（1aH）</p><p>八进制为O结尾，如：（17O）</p><p>十进制为D结尾，如：（12D）</p><p>二进制为B结尾，如：（110B）</p><h3 id="2-转换"><a href="#2-转换" class="headerlink" title="2.转换"></a>2.转换</h3><p><img src="https://github.com/SUDG01/tuchuang/blob/main/jinzhi1.png?raw=true"></p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/jinzhi2.png?raw=true"></p><p>计算方法。。。。。。</p><h3 id="3-整数编码"><a href="#3-整数编码" class="headerlink" title="3.整数编码"></a>3.整数编码</h3><p>表格法：1024 512 256 128 64 32 16 8 4 2 1 可以计算整数的原码</p><p>计算机使用补码</p><p>补码中负数等于绝对值的原码取反加一</p><h3 id="4-整数的存储方式"><a href="#4-整数的存储方式" class="headerlink" title="4.整数的存储方式"></a>4.整数的存储方式</h3><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs4.png?raw=true"></p><p>但是，x86（32位）系统则为低位优先，按图，则是78 56 34 12</p><h3 id="5-浮点数的定义和储存"><a href="#5-浮点数的定义和储存" class="headerlink" title="5.浮点数的定义和储存"></a>5.浮点数的定义和储存</h3><pre><code class="highlight c"><span class="type">float</span> x = <span class="number">1.732f</span>;<span class="type">double</span> y = <span class="number">3.1415926</span>;</code></pre><p>浮点数需要在常数后面加f声明为浮点数，双精度则不需要</p><p>单精度在二进制存储当中阶码部分占用8位，小数部分中占用23位</p><p>双精度在二进制存储当中阶码部分占用11位，小数部分中占用52位，两种精度都各保留一位符号位</p><p>0为正数，1为负数</p><h2 id="三-C语言中数据的类型"><a href="#三-C语言中数据的类型" class="headerlink" title="三.C语言中数据的类型"></a>三.C语言中数据的类型</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p>字符类型： char (ASCLL字符) &#x2F; wchar_t (UNICODE字符)  UNICODE字符需要在值前加L来声明</p><p>整型： short&#x2F;int&#x2F;long&#x2F;long long&#x2F;_int64</p><p>实数：单精度float  ，双精度double</p><p>有符号和无符号：signed&#x2F;unsigned, (signed)int&#x2F;(unsigned) int</p><p>布尔类型：bool , 0&#x2F;1(true&#x2F;false),C99&lt;stdbool.h&gt; </p><h3 id="2-Ascll编码"><a href="#2-Ascll编码" class="headerlink" title="2.Ascll编码"></a>2.Ascll编码</h3><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Ascall.png?raw=true"></p><p>其中英文大写和小写之间的差值为32，可以用代码表示为</p><pre><code class="highlight c"><span class="type">char</span> c = <span class="string">&#x27;M&#x27;</span>;c + <span class="string">&#x27;a&#x27;</span>-<span class="string">&#x27;A&#x27;</span>;<span class="comment">//大写转小写</span><span class="type">char</span> d = <span class="string">&#x27;m&#x27;</span>;d + <span class="string">&#x27;A&#x27;</span>-<span class="string">&#x27;a&#x27;</span><span class="comment">//小写转大写</span></code></pre><h3 id="3-整型"><a href="#3-整型" class="headerlink" title="3.整型"></a>3.整型</h3><p>int 和long int(long)占4个字节，long在linux里占8个字节</p><p>longlong（gc） 和 _int64（vc）占8个字节</p><p>bool的长度为1个字节，BOOL为4个字节</p><pre><code class="highlight c"><span class="type">long</span> a = <span class="number">100L</span>;<span class="type">unsigned</span> <span class="type">long</span> b = <span class="number">100UL</span>;<span class="type">long</span> <span class="type">long</span> c = <span class="number">100ll</span>;        <span class="comment">//linux</span>_int64 d = <span class="number">100</span>i64;          <span class="comment">//windows</span></code></pre><h3 id="4-自定义新的类型"><a href="#4-自定义新的类型" class="headerlink" title="4.自定义新的类型"></a>4.自定义新的类型</h3><pre><code class="highlight c"><span class="keyword">typedef</span> <span class="type">int</span> INT<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> UINT             <span class="comment">//重新定义类型，好处简洁，同一编码风格，容易在其他平台改动</span></code></pre><h3 id="5-范围"><a href="#5-范围" class="headerlink" title="5.范围"></a>5.范围</h3><p>char [0,255]，8位， short [0,65535] 16位</p><p>int [0,4294967295] 32位 </p><p>以上均为无符号，有符号范围则是 [ -2 ^(n-1),2^(n-1)-1 ]</p><p>*在linux中，超级用户的GID为0（数据溢出，即如果超过可表示的范围则从负数开始计算）</p><h3 id="6-类型转换"><a href="#6-类型转换" class="headerlink" title="6.类型转换"></a>6.类型转换</h3><p>强制转换，人为使变量的类型发生转变，用例：</p><pre><code class="highlight c"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;<span class="comment">//原类型</span><span class="type">short</span> i = (<span class="type">short</span>)c;             <span class="comment">//转换</span></code></pre><p>浮点数到整数，如：</p><pre><code class="highlight c"><span class="type">int</span> i = (<span class="type">int</span>)<span class="number">3.14</span>;<span class="type">int</span> b = (<span class="type">int</span>)<span class="number">3.74</span>;                       <span class="comment">//两个结果均为3，只取整，并不会四舍五入</span></code></pre><p>如果从大到小转换</p><pre><code class="highlight c"><span class="type">int</span> x = <span class="number">0x12345678</span>;<span class="type">short</span> y = (<span class="type">short</span>)x;</code></pre><p>数据会从高位开始截断，如上，int为4个字节的数据，而short为两个字节，所以，y的值则会是<strong>0x5678</strong></p><p>自动转换，遵循一个规则，所有运算中，必须全部转换成同一种类型的数据再进行运算</p><p>且自动转换是以运算中最长的一种类型统一转换</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs5.png?raw=true"></p><p>单精度转双精度则是通过截尾来实现，会丢失一定量的数据（要进行四舍五入操作）</p><p>若signed整型赋给长度相同的unsigned型变量，内部存储形式不变，但外部表示时总是无符号的</p><pre><code class="highlight c"><span class="type">short</span> s = <span class="number">-1</span>;<span class="type">unsigned</span> <span class="type">short</span> us =(<span class="type">unsigned</span> <span class="type">short</span>)s;us = <span class="number">65535</span></code></pre><h2 id="四-变量"><a href="#四-变量" class="headerlink" title="四.变量"></a>四.变量</h2><h3 id="1-变量命名和定义"><a href="#1-变量命名和定义" class="headerlink" title="1.变量命名和定义"></a>1.变量命名和定义</h3><p>命名原则:只能由字母，下划线和数字组成，但第一个字符必须为字母，下划线也被看做为字母，且不能用关键字来当做变量，大写字符一般用于定义常量</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs6.png?raw=true"></p><p>命名规则（例：匈牙利命名）</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs8.png?raw=true"></p><p>一般有4种命名方法：匈牙利，下划线（linux），驼峰，帕斯卡</p><pre><code class="highlight c"><span class="type">int</span> iMyData;     <span class="comment">//匈牙利</span><span class="type">int</span> my_data;     <span class="comment">//下划线</span><span class="type">int</span> myData;      <span class="comment">//驼峰</span><span class="type">int</span> MyData;      <span class="comment">//帕斯卡</span></code></pre><h3 id="2-变量类型"><a href="#2-变量类型" class="headerlink" title="2.变量类型"></a>2.变量类型</h3><p>共有：全局变量，全局静态变量，局部变量，局部静态变量，寄存器变量5种</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs7.png?raw=true"></p><h2 id="五-开始使用"><a href="#五-开始使用" class="headerlink" title="五.开始使用"></a>五.开始使用</h2><h3 id="1-输入与输出"><a href="#1-输入与输出" class="headerlink" title="1.输入与输出"></a>1.输入与输出</h3><p>使用scanf函数接收输入</p><p>用法(例)</p><pre><code class="highlight c"><span class="type">int</span> C;<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);              <span class="comment">//warning:4996,可能会出现安全问题，可使用scanf_s()</span><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,c);</code></pre><p>在连续两个接收数据时，因为用户按下了回车，而回车也会当做一个字符，所以会导致后面的接收被顶掉，所以应该在每次scanf后输入：</p><pre><code class="highlight c">fflush(<span class="built_in">stdin</span>);                  <span class="comment">//清空数据缓存区域</span><span class="comment">//或者</span><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>,%c);                <span class="comment">//在%c前加一个空格</span></code></pre><p>还有其他接收字符的函数,例：</p><pre><code class="highlight c"><span class="type">char</span> a = getch();              <span class="comment">//检测输入后自动下一步</span><span class="type">char</span> a1 = getchar();           <span class="comment">//等待回车</span></code></pre><p>也可以用_getch()代替</p><p>%号后面的值：(tips: hd &#x3D;短整型，ld &#x3D; 长整型，I64d &#x3D; _int64的整数)</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs9.png?raw=true"></p><p>浮点数tip: %.[数字]可以控制浮点数后面有几位小数</p><p>字符串：</p><pre><code class="highlight c">gets();                          <span class="comment">//可以用gets_s()代替</span><span class="built_in">puts</span>();                          <span class="comment">//可以避免scanf以空格结束的问题</span></code></pre><p>文件流: stdin(输入)，stdout(输出)，stderr(错误)</p><h3 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h3><p>()优先级最高，优先算括号内数</p><p>逻辑非! : !0&#x3D;1，!非零 &#x3D; 0    </p><p>自增，自减: i++,++i,i–,–i</p><p>i++和++i的区别</p><pre><code class="highlight c"><span class="type">int</span> i = <span class="number">0</span>;<span class="type">int</span> a = i++;                  <span class="comment">//先i=a,在i+1</span><span class="type">int</span> b = ++i;                  <span class="comment">//先i+1,再i=b</span></code></pre><p>&amp;&amp;(逻辑与，且)，||(逻辑或)，&amp;&amp;的优先级大于||</p><p>?：取两个数的最大值</p><pre><code class="highlight c">a&lt;b?a:b                   <span class="comment">//如果前式为真，则取a，为否，则取b</span></code></pre><p>,运算符是优先级最低的</p><p>贪心算法：</p><p>编译器从左到右开始对运算符号依次读取，直到无法再组成一个新的运算式，例</p><pre><code class="highlight c">a+++++b;                  <span class="comment">//解析结果为((a++)++)+b</span></code></pre><h3 id="3-随机数"><a href="#3-随机数" class="headerlink" title="3.随机数"></a>3.随机数</h3><p>rand函数，但是需要随机生成一个种子，用例（一百以内的随机数）：</p><pre><code class="highlight c">srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="number">0</span>));               <span class="comment">//取当前时间为随机数的种子</span><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++);&#123;    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,rand()%<span class="number">100</span>);                 <span class="comment">//除以100的余数，即余数小于100，得到100以内的随机数</span>&#125;</code></pre><h3 id="4-switch语句"><a href="#4-switch语句" class="headerlink" title="4.switch语句"></a>4.switch语句</h3><p>与if语句使用方法类似，下面为例：</p><pre><code class="highlight c"><span class="keyword">switch</span>()&#123;<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>;    <span class="keyword">do</span> something;<span class="keyword">break</span>;                      <span class="comment">//如果没有加break的话，语句会继续往下执行而不会跳出switch函数</span><span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>;    <span class="keyword">do</span> something;    <span class="keyword">break</span>;...&#125;</code></pre><h3 id="5-循环"><a href="#5-循环" class="headerlink" title="5.循环"></a>5.循环</h3><p>for()语句由三个部分组成( 初始化变量 ;  判断条件; 更新循环变量表达式 )</p><p>do while 循环</p><pre><code class="highlight c"><span class="keyword">do</span>                <span class="comment">//int i = 0 </span>&#123;    <span class="built_in">printf</span>(<span class="string">&quot;balabala&quot;</span>);    i++;&#125;<span class="keyword">while</span> (i&lt;<span class="number">10</span>);                             <span class="comment">//与while循环不同的是，是先执行，再进行判断</span></code></pre><h3 id="6-转向语句"><a href="#6-转向语句" class="headerlink" title="6.转向语句"></a>6.转向语句</h3><h4 id="1-goto语句-常用于出错处理，跳出多重循环，慎用"><a href="#1-goto语句-常用于出错处理，跳出多重循环，慎用" class="headerlink" title="1.goto语句(常用于出错处理，跳出多重循环，慎用)"></a>1.goto语句(常用于出错处理，跳出多重循环，慎用)</h4><pre><code class="highlight c"><span class="keyword">goto</span> L1;...L1;语句语句</code></pre><p>tip: 如果申请内存使用后不再需要，要记得free()释放内存，防止内存泄漏</p><h4 id="2-break和continue"><a href="#2-break和continue" class="headerlink" title="2.break和continue"></a>2.break和continue</h4><p>break函数用于退出循环，return用于退出整个函数,并提供返回值</p><p>continue用于进入下一次循环，当执行到continue语句时，当前循环语句将不会继续进行</p><h2 id="六-数组"><a href="#六-数组" class="headerlink" title="六.数组"></a>六.数组</h2><h3 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1.一维数组"></a>1.一维数组</h3><h4 id="1-随机访问-数组中每个数代表4个字节，那么就可以做到："><a href="#1-随机访问-数组中每个数代表4个字节，那么就可以做到：" class="headerlink" title="1.随机访问,数组中每个数代表4个字节，那么就可以做到："></a>1.随机访问,数组中每个数代表4个字节，那么就可以做到：</h4><pre><code class="highlight c"><span class="type">int</span> a[<span class="number">10</span>];               <span class="comment">//假如要访问数组中第6个值</span>a[<span class="number">0</span>]+<span class="number">20</span>;                 <span class="comment">//加20得到的即为第六个值的地址</span></code></pre><h4 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h4><pre><code class="highlight c"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;<span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;                         <span class="comment">//没有初始化的值均为0</span><span class="type">int</span> a[<span class="number">10</span>] = &#123;(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">3</span>),<span class="number">4</span>&#125;                     <span class="comment">//逗号表达式，结果等价于&#123;1,3,4&#125;</span><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;                                 <span class="comment">//全部初始化为0</span><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</code></pre><h4 id="3-字符数组"><a href="#3-字符数组" class="headerlink" title="3.字符数组"></a>3.字符数组</h4><pre><code class="highlight c"><span class="type">char</span> str1[] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;;<span class="type">char</span> str2[] = <span class="string">&quot;hello&quot;</span>；                    <span class="comment">//看起来相同，但是str2比str1多1个\0作为结束符</span></code></pre><p>tip:数组名是常量指针，一旦定义，就不能修改，如：</p><pre><code class="highlight c"><span class="type">char</span> a[<span class="number">100</span>];a = <span class="string">&quot;hello world&quot;</span>                          <span class="comment">//error</span></code></pre><h3 id="2-二维数组"><a href="#2-二维数组" class="headerlink" title="2.二维数组"></a>2.二维数组</h3><p>定义方式：(因为量大，不好直接写，直接放图)</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/Cs10.png?raw=true"></p><p>初始化：</p><pre><code class="highlight c"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">23</span>,<span class="number">34</span>,<span class="number">21</span>&#125;,&#123;<span class="number">72</span>,<span class="number">2</span>,<span class="number">31</span>&#125;,&#123;<span class="number">123</span>,<span class="number">23</span>,<span class="number">5</span>&#125;,...&#125;;</code></pre><h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h3><p>在数组中，如果有整数型数组a1[5]&#x3D;{0};     a2[3][4]&#x3D;{0}；假设a1的起始地址为:10000000,a2的起始地址为200000000</p><p>对数组进行+1操作可以得到：</p><pre><code class="highlight c">a1 + <span class="number">1</span> = <span class="number">100000004</span>;           &amp;a1 + <span class="number">1</span> = <span class="number">200000020</span>;a2 + <span class="number">1</span> = <span class="number">100000016</span>;           &amp;a2 + <span class="number">1</span> = <span class="number">200000048</span>;</code></pre><p>在数组中，一行算一个元素，一个元素4个字节，a1+1的值则加一个元素，而&amp;a1为数组的地址，则加一整个地址，有5个元素，则加4*5&#x3D;20</p><p>a2有4行，算4个元素，则a2+1的地址加16，&amp;a2则有总共12个元素，则地址加3*4*4&#x3D;48</p><p>&#x2F;&#x2F;P26 30:30</p><h4 id="数组的溢出"><a href="#数组的溢出" class="headerlink" title="数组的溢出"></a>数组的溢出</h4><p>C编译器对数组溢出不做检测<br>程序在运行时候，数组溢出导致程序行为未定义</p><h3 id="4-数组的应用"><a href="#4-数组的应用" class="headerlink" title="4.数组的应用"></a>4.数组的应用</h3><h4 id="1-计算斐波那契数组"><a href="#1-计算斐波那契数组" class="headerlink" title="1.计算斐波那契数组"></a>1.计算斐波那契数组</h4><p><img src="https://github.com/SUDG01/tuchuang/blob/main/flpq_math.png?raw=true"></p><h4 id="2-字符串大小写转换"><a href="#2-字符串大小写转换" class="headerlink" title="2.字符串大小写转换"></a>2.字符串大小写转换</h4><p><img src="https://github.com/SUDG01/tuchuang/blob/main/transtr.png?raw=true"></p><h4 id="3-计算平均值"><a href="#3-计算平均值" class="headerlink" title="3.计算平均值"></a>3.计算平均值</h4><p>定义一个数组，通过for循环遍历整个数组，令数组不断自增，最后再除以数组中数据的数量</p><h4 id="4-取最大值"><a href="#4-取最大值" class="headerlink" title="4.取最大值"></a>4.取最大值</h4><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/get_max_num.png?raw=true"></p><h2 id="七-字符串"><a href="#七-字符串" class="headerlink" title="七.字符串"></a>七.字符串</h2><p>C语言中字符串可以定义为:”c1,c2.c3…..cn \0”其中\0是结束符，算作一个字符</p><h3 id="1-转义字符"><a href="#1-转义字符" class="headerlink" title="1.转义字符"></a>1.转义字符</h3><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs11.png?raw=true"></p><p>字符串(“a”)和字符常量(‘a’)的区别</p><p>字符串是存储在静态区的，”a”对应的是字符串的首地址,所以可以赋值给字符指针</p><p>而字符常量’a’只是赋值给变量，不存储在静态区域，没有内存，不可赋值给字符指针</p><h3 id="2-宽字符串"><a href="#2-宽字符串" class="headerlink" title="2.宽字符串"></a>2.宽字符串</h3><p>wchat_t类型</p><pre><code class="highlight c"><span class="type">wchar_t</span> a = <span class="string">L&quot;Hello,世界&quot;</span>；</code></pre><p>宽字符串相比普通字符串，其中所有的字符都占两个字节，但是响应速度更快</p><h3 id="3-使用malloc函数动态分配内存调用字符串"><a href="#3-使用malloc函数动态分配内存调用字符串" class="headerlink" title="3.使用malloc函数动态分配内存调用字符串"></a>3.使用malloc函数动态分配内存调用字符串</h3><p>用例:</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs12.png?raw=true"></p><p>把字符串存放在堆上来调用字符串</p><p>这样，可以通过指针移动来遍历整个字符串，知道遇到字符’\0’</p><h3 id="4-字符串做函数参数"><a href="#4-字符串做函数参数" class="headerlink" title="4.字符串做函数参数"></a>4.字符串做函数参数</h3><pre><code class="highlight c"><span class="type">void</span> <span class="title function_">print_str</span><span class="params">(<span class="type">char</span> *str)</span>&#123;    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)&#123;        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*str);        <span class="comment">//定义一个函数，不断遍历指针*str的字符，直到遇到&#x27;\0&#x27;</span>        str++;    &#125;&#125;<span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;    <span class="type">char</span> *str = <span class="string">&quot;hello world&quot;</span>;       <span class="comment">//向指针中传递参数，用定义的函数print_str输出</span>    print_str(str);    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre><h3 id="5-字符串api"><a href="#5-字符串api" class="headerlink" title="5.字符串api"></a>5.字符串api</h3><p>有3套库函数，strxxx&#x2F;wcsxxx&#x2F;_tcsxxx，建议使用tchar的写法(兼容多字节字符集工程和UNICODE字符集工程):</p><pre><code class="highlight c"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span>TCHAR *tstr = _T(<span class="string">&quot;Hello world&quot;</span>);</code></pre><ul><li>strcpy 将字符串拷贝到另一个变量或数组</li></ul><pre><code class="highlight c"><span class="built_in">strcpy</span>(要拷贝到的变量或数组,原位置);<span class="built_in">strcpy</span>(buf1,s1);_tcscpy(buf2,s2);</code></pre><ul><li>strcmp比较两个字符串</li></ul><pre><code class="highlight c"><span class="built_in">strcmp</span>(s1,s2);<span class="built_in">strncmp</span>(s1,s2,<span class="number">5</span>);        <span class="comment">//用于比较字符串中前几个字符是否相等</span>stricmp(s1,s2);          <span class="comment">//忽略大小写</span>strnicmp(s1,s2,<span class="number">3</span>);       <span class="comment">//与strncmp相同，忽略大小写</span></code></pre><ul><li>strcat拼接两个字符串</li></ul><pre><code class="highlight c"><span class="type">char</span> path[<span class="number">260</span>] = <span class="string">&quot;c:\\doc\\test\\&quot;</span>;<span class="type">char</span> *filename = <span class="string">&quot;meow.txt&quot;</span>;<span class="built_in">strcat</span>(path,filename);<span class="built_in">printf</span>(<span class="string">&quot;path:%s\n&quot;</span>,path);</code></pre><ul><li>strchr(strrchr)查找</li></ul><pre><code class="highlight c"><span class="type">char</span> *p = <span class="built_in">strchr</span>(path,<span class="string">&#x27;x&#x27;</span>);</code></pre><p>用于从左到右查找字符串中的一个字符是否存在，若存在，则输出以后的所有内容(如果是strrchr则是从右往左)</p><p>同样的strstr可以查找字符串，用法类似</p><ul><li>strtok分割（两个参数，strtok(要分割的字符串,分割符)）</li></ul><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs13.png?raw=true"></p><ul><li>atoi(字符串转整型)&#x2F;atof(字符串转浮点)&#x2F;atol(字符串转长整型)&#x2F;atoll(字符串转long long)&#x2F;_ttol(针对TCHAR)</li></ul><h2 id="八-函数"><a href="#八-函数" class="headerlink" title="八.函数"></a>八.函数</h2><p>在C中，把为了实现某一特定的功能的所有语句归纳在一起，就形成了一个函数。一般来说，函数只实现单一功能</p><p>引用自己的函数:</p><p>1.创建一个.cpp源文件，将函数写进.cpp文件中，函数在写的时候需要一个返回值，ruturn函数计算的结果</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/func1.png?raw=true"></p><p>2.创建一个.h头文件,在头文件中写入引用的函数(#pragma once是用于同一个头文件被包含多次)</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/func2.png?raw=true"></p><p>同时，ifndef也可以保证头文件只被一次包含</p><pre><code class="highlight c"><span class="meta">#<span class="keyword">ifndef</span> _Exemple_</span><span class="meta">#<span class="keyword">define</span> _Exemple_</span>....(包含的函数)<span class="meta">#<span class="keyword">endif</span></span></code></pre><p>3.使用(#include “要包含的自己创建的头文件”)</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/func3.png?raw=true" alt="使用"></p><h3 id="1-命令行参数"><a href="#1-命令行参数" class="headerlink" title="1.命令行参数"></a>1.命令行参数</h3><pre><code class="highlight c"><span class="type">int</span> _tmain(<span class="type">int</span> argc,_TCHAR* argv[])&#123;    ...&#125;</code></pre><p>其中,argc为命令行参数的个数,argv[]存放命令行参数</p><h3 id="2-函数的注意事项-模块化-方便调试-维护"><a href="#2-函数的注意事项-模块化-方便调试-维护" class="headerlink" title="2.函数的注意事项(模块化,方便调试,维护)"></a>2.函数的注意事项(模块化,方便调试,维护)</h3><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs14.png?raw=true"></p><ul><li>变量初始化，在函数局部变量要保证初始化</li><li>严进宽出: 在一开始排除非法数据，后面轻松</li><li>assert：对参数进行断言</li><li>时间与空间复杂度: 内存少，使用快，尽量优化，不要分配内存(malloc)</li><li>边界考虑: 对条件充分考虑，避免特殊情况发生</li><li>功能测试: 在不同用例中测试函数的功能是否运行正常</li></ul><h3 id="3-库函数"><a href="#3-库函数" class="headerlink" title="3.库函数"></a>3.库函数</h3><p>库函数都有官方的说明文档，可以通过官方文档来进行传参，调试</p><h3 id="4-errno-t函数"><a href="#4-errno-t函数" class="headerlink" title="4.errno_t函数"></a>4.errno_t函数</h3><p>errno_t函数可以用来查看错误码(存放在头文件<strong>Windows.h</strong>中)，用例:</p><pre><code class="highlight c"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>...<span class="type">errno_t</span> err = GetLastError();<span class="built_in">printf</span>(<span class="string">&quot;err: %d&quot;</span>,err);</code></pre><p>例:传回来的错误码可以在工具Error Lookup(错误查找)中查看(visual stdudio):</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Error_Lookup.png?raw=true"></p><h3 id="5-面向过程和面向对象"><a href="#5-面向过程和面向对象" class="headerlink" title="5.面向过程和面向对象"></a>5.面向过程和面向对象</h3><p>C语言是面向过程的一门编程语言</p><p>两者的区别是:</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs15.png?raw=true"></p><p>面向对象,所有的动作都对应一个对象</p><p>面向过程,每个动作都是从一个动词开始的，每个动作对应一个函数</p><h3 id="6-函数的传参"><a href="#6-函数的传参" class="headerlink" title="6.函数的传参"></a>6.函数的传参</h3><p>3种方式</p><p>1.传值: 形参是对实参值的一个拷贝，形参和实参是不相关。无法通过改变形参来改变实参</p><p>2.传指针: 形参是对实参地址的一个拷贝，通过地址可以实现对实参的修改</p><p>3.传引用: 形参是对实参的一个引用（别名），形参就是实参本身，改变形参就是改变实参本身</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs16.png?raw=true"></p><p>函数用参数作为返回值</p><ul><li>变量既是输入，也是输出参数</li></ul><pre><code class="highlight c"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> *x,<span class="type">int</span> y)</span>;          <span class="comment">//*x = *x + y;</span></code></pre><p>数组做函数参数，防溢出：</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs17.png?raw=true"></p><h3 id="7-函数的调用约定"><a href="#7-函数的调用约定" class="headerlink" title="7.*函数的调用约定"></a>7.*函数的调用约定</h3><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/callingcvt1.png?raw=true"></p><p>默认调用约定:</p><pre><code class="highlight c"><span class="type">int</span> <span class="title function_">func</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</code></pre><p>cdecl调用约定:(参数入栈顺序：从右到左。调用者修改栈，所以可以支持变参函数，因为能恢复栈平衡)</p><pre><code class="highlight c">int__cdecl <span class="title function_">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;               <span class="comment">//先是y入栈，再是x</span></code></pre><p>stdcall调用约定:（从右往左压入栈。被调用函数自身修改栈）</p><pre><code class="highlight c">int__stdcall <span class="title function_">func</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</code></pre><p>fastcall调用约定:(函数的第一个和第二个通过ecx和edx传递，剩余参数从右到左入栈。被调用者修改栈)</p><pre><code class="highlight c">int__fastcall <span class="title function_">func</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span>;</code></pre><p> <strong>栈</strong>的增长方向和内存增长方向相反</p><p>先是参数入栈，然后是返回地址入栈（<strong>eip</strong>）(调用完当前函数后下一条要执行的指令)，接着是ebp寄存器入栈(debug版本)，最后是esp寄存器（占领寄存器），然后得到局部变量区的空间。<br>函数调用完之后，开始出栈，esp到达参数区域时，要使内存完全释放，需要+（对应参数的值）*4+4</p><p><u>每个参数在入栈时都会被提升至4个字节</u></p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs18.png?raw=true"></p><p><strong>x64平台统一使用fastcall约定</strong></p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs19.png?raw=true"></p><p>区别:</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs20.png?raw=true"></p><h3 id="8-inline（内联函数）"><a href="#8-inline（内联函数）" class="headerlink" title="8.inline（内联函数）"></a>8.inline（内联函数）</h3><p>优点:没有栈操作，运行效率高<br>缺点:代码会变大</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/img/Cs21.png?raw=true"></p><h3 id="9-static关键字"><a href="#9-static关键字" class="headerlink" title="9.static关键字"></a>9.static关键字</h3><p>static(静态)，限制函数只在当前文件下使用，防止命名冲突</p><h3 id="10-函数设计的常见问题"><a href="#10-函数设计的常见问题" class="headerlink" title="10.函数设计的常见问题"></a>10.函数设计的常见问题</h3><h4 id="1-printf打印结果代替返回值"><a href="#1-printf打印结果代替返回值" class="headerlink" title="1.printf打印结果代替返回值"></a>1.printf打印结果代替返回值</h4><p>输出结果返回给调用者，printf没有任何意义，调用者是看不到的</p><h4 id="2-逻辑全部或者部分放在了main函数"><a href="#2-逻辑全部或者部分放在了main函数" class="headerlink" title="2.逻辑全部或者部分放在了main函数"></a>2.逻辑全部或者部分放在了main函数</h4><p>算法必须单独写成普通函数，然后在main函数里测试。main里不能有算法逻辑或者功能部分，main只负责数据测试</p><h4 id="3-调用了库函数"><a href="#3-调用了库函数" class="headerlink" title="3.调用了库函数"></a>3.调用了库函数</h4><h4 id="4-代码缺少封装"><a href="#4-代码缺少封装" class="headerlink" title="4.代码缺少封装"></a>4.代码缺少封装</h4><h4 id="5-函数内部内存分配"><a href="#5-函数内部内存分配" class="headerlink" title="5.函数内部内存分配"></a>5.函数内部内存分配</h4><h4 id="6-硬编码"><a href="#6-硬编码" class="headerlink" title="6.硬编码"></a>6.硬编码</h4><h4 id="7-指针移动"><a href="#7-指针移动" class="headerlink" title="7.指针移动"></a>7.指针移动</h4><p>一块N个字节的内存，它的首地址（头指针）为pstart，那么末地址为：</p><pre><code class="highlight c">pStart+N<span class="number">-1</span>;</code></pre><h2 id="九-指针"><a href="#九-指针" class="headerlink" title="九.指针"></a>九.指针</h2><p>指针就是一个变量(x86 占4个字节,x64占8个自己字节)，它与其他变量的不同就在于它的值是一个内存地址，指向内存的某一个地方，明确了该内存的宽度（通过指针类型确定）。指针含义分为3个方面：（变量&amp;&amp;地址&amp;&amp;内存宽度）</p><h3 id="解引用（dereference）运算符"><a href="#解引用（dereference）运算符" class="headerlink" title="*解引用（dereference）运算符"></a>*解引用（dereference）运算符</h3><p>通过指针（存放的内存地址），找到对应的内存和里面存放的数据类似于邮递员根据信封地址，找到地点</p><p>&amp;和*互为逆运算</p><p>*&amp;与&amp;*(&amp;:取变量的地址,*:取地址对应的内存)，如果为void类型，那么长度不确定,GCC中默认为1字节</p><pre><code class="highlight c"><span class="type">int</span> a = <span class="number">10</span>;*&amp;a == a;&amp;*a;   <span class="comment">//error</span><span class="type">int</span> *p = &amp;a;*p == a;*&amp;p == p;&amp;*p == p;</code></pre><h3 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h3><p>一级指针中存放的是普通变量的内存地址，二级指针中存放的是一级指针的地址</p><p>作用:传参是改变一级指针的值</p><p>传参：</p><pre><code class="highlight c"><span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> x)</span>;          <span class="comment">//传实参值，不能改变实参</span><span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> *x)</span>;         <span class="comment">//穿实参指针，修改实参</span><span class="type">int</span> <span class="title function_">func3</span><span class="params">(<span class="type">int</span> &amp;x)</span>;         <span class="comment">//传实参引用，修改实参</span><span class="type">int</span> <span class="title function_">func4</span><span class="params">(<span class="type">int</span> **x)</span>;        <span class="comment">//实参是指针，传指针的指针，修改指针</span><span class="type">int</span> <span class="title function_">func5</span><span class="params">(<span class="type">int</span> *&amp;x)</span>;        <span class="comment">//实参是指针，传指针的引用，修改指针</span></code></pre><h2 id="十-内存"><a href="#十-内存" class="headerlink" title="十.内存"></a>十.内存</h2>]]></content>
      
      
      <categories>
          
          <category> 周报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一周学习笔记</title>
      <link href="/2024/09/29/%E7%AC%AC%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/09/29/%E7%AC%AC%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><em><strong>实验室第一周学习内容：</strong></em></p><h1 id="1-搭建个人博客"><a href="#1-搭建个人博客" class="headerlink" title="1.搭建个人博客"></a>1.<strong>搭建个人博客</strong></h1><p>采用了hexo框架，windows安装git后使用git依次输入</p><pre><code class="highlight git">npm install -g hexo-cli     #全局安装hexohexo init                   #初始化博客npm install                 #安装hexo依赖包</code></pre><p>选定文件夹后git clone拉取hexo仓库后本地输入</p><pre><code class="highlight hexo">hexo s</code></pre><p>本地博客就在localhost上运行了，浏览器输入<a href="http://localhost:4000即可访问">http://localhost:4000即可访问</a></p><p>本地博客搭建完毕后，需要在公网上可以访问展示，使用github仓库为媒介，搭建博客</p><p>第一步是设置ssh密钥，在git上生成rsa密钥，输入</p><pre><code class="highlight git">ssh-keygen -t rsa -C &quot;xxxx@qq.com&quot;       #生成密钥，xxx填邮箱地址</code></pre><p>复制密钥后在github上创建两个ssh密钥连接</p><p>一个是sighin一个是auth</p><p>验证可以和github仓库连接后，输入</p><pre><code class="highlight plaintext">hexo g                          #生成html网页hexo d                          #deploy部署到github仓库</code></pre><p>随后访问<a href="https://sudg01.github.io/">https://sudg01.github.io/</a> 即可连接到博客网页</p><p>正好手头上有空闲的域名，使用域名CNAME解析到github仓库博客网页，再在github仓库界面设置好解析的域名，即可正常使用域名访问 <a href="https://sudg01.github.io/">blog.5x1ng.cn</a></p><h1 id="2-linux的指令学习—在RUNOOB-COM上学习"><a href="#2-linux的指令学习—在RUNOOB-COM上学习" class="headerlink" title="2.linux的指令学习—在RUNOOB.COM上学习"></a><strong>2.linux的指令学习—在RUNOOB.COM上学习</strong></h1><p>由于本机在招新赛时安装了Ubuntu20.04系统，于是直接使用Ubuntu系统进行linux的学习</p><p>Linux系统目录结构</p><p>1.ls 命令</p><pre><code class="highlight linux">ls</code></pre><h2 id="系统根目录下的目录解释"><a href="#系统根目录下的目录解释" class="headerlink" title="系统根目录下的目录解释"></a><strong>系统根目录下的目录解释</strong></h2><p>&#x2F;bin         存放命令                                                                                  &#x2F;media            识别的设备</p><p>&#x2F;boot      存放linux核心文件          &#x2F;mnt                临时文件挂载目录</p><p>&#x2F;dev        即divice，设备文件&#x2F;opt                 额外软件安装目录</p><p>&#x2F;etc         放置所有系统管理所需文件   &#x2F;proc               该目录在系统内存里，而不是在</p><p>​  硬盘里</p><p>&#x2F;home    用户目录                                                  &#x2F;root               超级权限者目录</p><p>&#x2F;lib          库文件      &#x2F;sbin               超级权限者的系统目录</p><p>&#x2F;srv         服务启动后要获取的数据                                                       &#x2F;sys                 系统文件</p><p>&#x2F;tmp       临时文件                                                                                  &#x2F;usr                 类似windows的program files文 件夹</p><p>&#x2F;usr&#x2F;bin   系统用户使用的应用程序     &#x2F;usr&#x2F;sbin        超级用户的程序</p><p>&#x2F;usr&#x2F;src    内核源代码默认目录                                                            &#x2F;var                 经常被修改的目录和各种日志文 件</p><p>&#x2F;run           储蓄启动以来所有的临时文件，系统重启后会清空</p><p>在linux中  <u>.&#x2F;代表当前目录</u>，<u>..&#x2F;代表上级目录</u></p><h2 id="linux文件基本属性"><a href="#linux文件基本属性" class="headerlink" title="linux文件基本属性"></a><strong>linux文件基本属性</strong></h2><p>可以用ll 或者ls -l来查看文件的属性以及所属的用户和组</p><p>有两个命令可以修改权限，分别为<u>chown</u>和<u>chmod</u>和<u>chgrp</u>命令</p><pre><code class="highlight linux">llls -l                       #查看文件权限</code></pre><p>chown：更改文件所有者<br>chgrp ：更改文件属组</p><p>chmod：更改文件9个属性</p><p>语法</p><pre><code class="highlight linux">chgrp [-R] 属组名 文件名chown [-R] 所有者 文件名chown [-R] 所有者:属组名 文件名</code></pre><p>r:4（读）                  w:2（写）                     x:1（执行）</p><p>owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</p><p>group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</p><p>others &#x3D; 0 + 0 + 0 &#x3D; 0</p><p>所以，chmod语法应该是</p><pre><code class="highlight linux">chmod [-R] xyz 文件或目录chmod 777 number</code></pre><p><img src="https://github.com/SUDG01/tuchuang/blob/main/learnlinux.png?raw=true"></p><h2 id="处理目录的常用指令"><a href="#处理目录的常用指令" class="headerlink" title="处理目录的常用指令"></a><strong>处理目录的常用指令</strong></h2><pre><code class="highlight plaintext">ls        #列出目录cd        #切换目录pwd       #显示目前目录mkdir     #创建一个新的目录rmdir     #删除一个空的目录cp        #复制文件或目录rm        #删除文件或目录，删除文件目录需要加-rmv        #移动文件或目录或修改名称</code></pre><h2 id="用户和用户组管理"><a href="#用户和用户组管理" class="headerlink" title="用户和用户组管理"></a><strong>用户和用户组管理</strong></h2><p>新建账号</p><pre><code class="highlight plaintext">useradd [选项] 用户名</code></pre><p>-c  comment</p><p>-d  目录</p><p>-g  用户组</p><p>-G  用户组 用户组</p><p>-s  Shell文件</p><p>-u  用户号</p><p>删除账号</p><pre><code class="highlight plaintext">userdel -r 用户名             #删除用户并删除主目录</code></pre><p>修改账号</p><pre><code class="highlight plaintext">usermod 选项 用户名</code></pre><p>切换账号</p><pre><code class="highlight plaintext">su 用户su                        #均需要管理员权限，单个su为切换为root账户</code></pre><p>用户名口令的管理</p><pre><code class="highlight plaintext">passwd 选项 用户名passwd                             #如果已经为该用户，直接输入即可进入修改流程</code></pre><p>增加用户组以及删除用户组和用户组属性的修改</p><pre><code class="highlight plaintext">groupadd 选项 用户组groupdel 用户组groupmod 选项 用户组</code></pre><p>-g GID 制定新的组标识号</p><p>-o -g 新用户可以与系统已有用户组的GID相同</p><p>-n 新用户组</p><h2 id="VI-VIM"><a href="#VI-VIM" class="headerlink" title="VI&#x2F;VIM"></a><strong>VI&#x2F;VIM</strong></h2><p><img src="https://github.com/SUDG01/tuchuang/blob/main/vim.png?raw=true" alt="vim"></p><pre><code class="highlight plaintext">i               #切换到输入模式，在光标当前位置开始输入文本x               #删除当前光标所在处的字符:               #切换到底线命令模式，以在最底一行输入命令a               #进入插入模式，在光标下一个位置开始输入文本o：             #在当前行的下方插入一个新行，并进入插入模式O               #在当前行的上方插入一个新行，并进入插入模式dd              #剪切当前行yy              #复制当前行p               #粘贴剪贴板内容到光标下方P               #粘贴剪贴板内容到光标上方u               #撤销上一次操作Ctrl + r        #重做上一次撤销的操作:w              #保存文件:q              #退出 Vim 编辑器:q!             #强制退出Vim 编辑器，不保存修</code></pre><p><strong>替换文本</strong></p><pre><code class="highlight plaintext">:s/旧字符串/新字符串                    #替换首个字符串:s/旧字符串/新字符串/g                  #替换光标所在行所有字符串:%s/旧/新/g                           #全文替换</code></pre><p><strong>查找文本</strong></p><p>处于交互模式，按下&#x2F;键，进入查找模式，输入字符串即可</p><p>n键：跳转到下一个匹配项</p><p>N键：跳转到上一个匹配项</p><p>tip:在vim中，撤销操作在命令模式下按<strong>u</strong>即可，取消撤销则为<strong>ctrl+r</strong></p><h2 id="yum和apt"><a href="#yum和apt" class="headerlink" title="yum和apt"></a><strong>yum和apt</strong></h2><p>由于yum指令是在CentOS&#x2F;redshell等系统上默认使用的，而Ubuntu是默认使用apt指令，安装yum库报错，且yum和apt的用法极为相似，所以我重点先学习apt</p><p>通常安装软件包更多还是使用apt-get，apt-get属于apt，属于更底层的工具，可以更好地控制包管理过程</p><p>使用apt指令的时候需要管理员权限，所以一般会在指令前加sudo指令，以超级用户权限进行操作</p><p>安装包</p><pre><code class="highlight plaintext">sudo apt install  包名sudo apt-get install  包名         #均为安装包</code></pre><p>检测是否存在并升级</p><pre><code class="highlight plaintext">sudo apt install 包名 --no-upgrade</code></pre><p>只升级，如果不存在就不升级</p><pre><code class="highlight plaintext">sudo apt install 包名 --only-upgrade</code></pre><p>移除包</p><pre><code class="highlight plaintext">sudo apt remove 包名</code></pre><p><strong>如何找出相关文件</strong></p><pre><code class="highlight plaintext">whereis [名称]</code></pre><p><img src="https://github.com/SUDG01/tuchuang/blob/main/626a4528-0ced-4123-8441-5c6488f24ead.png?raw=true"></p><p>即可找出所有相关的文件或文件夹</p><p><strong>下载文件</strong></p><pre><code class="highlight plaintext">wget 文件地址</code></pre><p><strong>打开文件（5个命令）</strong></p><p>1.cat命令</p><pre><code class="highlight plaintext">cat [文件或文件路径]</code></pre><p>2.more命令</p><pre><code class="highlight plaintext">more [文件或文件路径]                   #不展示全部，翻页使用，文本内容较多时可以使用</code></pre><p>如果想提前终止查看，按q即可终止查看</p><p>3.less命令</p><pre><code class="highlight plaintext">less [文件或文件路径]                    #与more类似，可以操作上下翻页，按q退出</code></pre><p>u:向上</p><p>j:向下</p><p>g:跳到第一行</p><p>G:跳到最后一行</p><p>4，head命令</p><pre><code class="highlight plaintext">head [参数] [文件或文件路径]               #查看文件的开头部分，默认看前面十行</code></pre><p>-n 指定看多少行的内容</p><p>-c 指定看多少个字节的内容</p><p>5.tail命令</p><pre><code class="highlight plaintext">tail [参数] [文件或文件路径]                 #查看文件的末尾部分，和head命令类似</code></pre><p><strong>查找文件</strong></p><p>find 命令</p><pre><code class="highlight plaintext">find [路径] [参数] [要查找的内容]</code></pre><p>-name 按名字查找</p><p>-size 按文件大小查找</p><p>示例:</p><pre><code class="highlight plaintext">find / -name &quot;text*&quot;                       #查找以text开头的文件，*是通配符,/是从根目录下查找find / -size +10M                          #查找大于10MB的文件</code></pre><p>在-size选项中，+代表大于，-代表小于</p><p><img src="https://github.com/SUDG01/tuchuang/blob/main/find.png?raw=true"></p><p>如图，输入find &#x2F; -name “text*”，即把所有以text为开头的文件查找出来</p><hr><p>还有一些小tip：</p><p>ctrl+c可以关闭不需要的实例</p><p>Tab键可以补齐指令</p><p>Ctrl+L  清屏</p><hr><p>第一周的学习非常充实</p><p>学习了github的基本使用以及博客和github的联系使用</p><p>还有linux的一些基本使用方式</p><p>内容非常多，还需要多巩固复习！！！</p>]]></content>
      
      
      <categories>
          
          <category> 周报 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到SU小喵の小站</title>
      <link href="/2024/09/29/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0SU%E5%B0%8F%E5%96%B5%E3%81%AE%E5%B0%8F%E7%AB%99/"/>
      <url>/2024/09/29/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0SU%E5%B0%8F%E5%96%B5%E3%81%AE%E5%B0%8F%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p>Hallo，大家好！！</p><p>这里是SUX1NG，是一只小狐喵</p><p>随着时间的推移，小喵也是来到了大学，见识到了许多新的事物，也向着更发高难度的学业开始了自己的旅程 为此，小喵建设了一个属于自己的blog，以此来记录小喵在大学四年的学习生活，并希望能够记录到许多美好的事物&#x3D; v &#x3D; </p><p>emmmmmmmmmm</p><p>最后 </p><p>欢迎你来访问我的小网站！！！！！ </p><p>xwx</p>]]></content>
      
      
      <categories>
          
          <category> G3t5tart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> firstblog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
